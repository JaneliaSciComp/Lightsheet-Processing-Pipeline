function multiFuse(parameterDatabase, t, memoryEstimate)% -----------------------------------------------------------------------------------------------% | Image data fusion for simultaneous multi-view light sheet microscopy                        |% |                                                                                             |% | Bi-directional illumination dual-camera image stack registration and fusion,                |% | using adaptive slicing, correlation by rigid transformation and adaptive fusion             |% | by linear short-distance blending, arithmetic averaging or wavelet decomposition            |% |                                                                                             |% | Code by Philipp J. Keller, HHMI/Janelia Research Campus, 2011-2015                          |% | Email: kellerp@janelia.hhmi.org                                                             |% |                                                                                             |% | Utilizes optimization modules and functions by Fernando Amat, HHMI/Janelia Research Campus: |% | imgaussianAnisotropy.m (included below)                                                     |% | fminuncFA.m            (included below)                                                     |% | transformCamera.m      (included below)                                                     |% | transformChannel.m     (included below)                                                     |% | readKLBstack.mexw64                                                                         |% | writeKLBstack.mexw64                                                                        |% |                                                                                             |% | Utilizes optimization modules from the MathWorks File Exchange:                             |% | fInterpolate.mexw64 (ba_interp2.mexw64)                                                     |% -----------------------------------------------------------------------------------------------% Output required by timeFuse.m:% CMXX_CHNAA_CHNBB.fusionMask.*% CMYY_CHNAA_CHNBB.fusionMask.*% CMXX_CMYY_CHNAA_CHNBB.fusionMask.*% lookUpTable.mat (post-processed table of spatial transformations and intensity correction parameters)% spatial transformation: CMXX_CHNAA_CHNBB.transformation.mat,      CMYY_CHNAA_CHNBB.transformation.mat,      CMXX_CMYY_CHNAA_CHNBB.transformation.mat% intensity correction:   CMXX_CHNAA_CHNBB.intensityCorrection.mat, CMYY_CHNAA_CHNBB.intensityCorrection.mat, CMXX_CMYY_CHNAA_CHNBB.intensityCorrection.matload(parameterDatabase);timepoint = timepoints(t);version = 1.19;configuration = cell(43, 1);configuration{1}  = version;      configuration{2}  = timepoint;    configuration{3}  = inputString;  configuration{4}  = outputString; configuration{5}  = outputID;    configuration{6}  = dataType;configuration{7}  = specimen;     configuration{8}  = cameras;      configuration{9}  = channels;     configuration{10} = reducedIO;    configuration{11} = inputType;   configuration{12} = outputType;configuration{13} = splitting;    configuration{14} = kernelSize;   configuration{15} = kernelSigma;  configuration{16} = fraction;configuration{17} = maskMinimum;  configuration{18} = maskFactor;   configuration{19} = maskFusion;   configuration{20} = padding;      configuration{21} = slabSizes;   configuration{22} = intSizes;configuration{23} = percentile;   configuration{24} = subSampling;  configuration{25} = medianFilter; configuration{26} = preciseGauss; configuration{27} = gaussFilter;configuration{28} = optimizer;    configuration{29} = correction;   configuration{30} = fusionType;   configuration{31} = transitions;  configuration{32} = blending;configuration{33} = enforceFlag;  configuration{34} = verbose;      configuration{35} = cropping;     configuration{36} = scaling;      configuration{37} = leftFlags;configuration{38} = flipHFlag;    configuration{39} = flipVFlag;    configuration{40} = xOffsets;     configuration{41} = yOffsets;     configuration{42} = frontFlag;configuration{43} = [jobMemory(1) memoryEstimate];%% main loopif length(cameras) == 2 && length(channels) == 2    processingMode = 0; % 4-view fusionelseif length(cameras) == 1 && length(channels) == 2    processingMode = 1; % 2-view channel fusionelseif length(cameras) == 2 && length(channels) == 1    processingMode = 2; % 2-view camera fusionelse    error('Error: Provide either 2 channels and 2 cameras (4-view fusion) or 2 channels and 1 camera (2-view channel fusion) or 1 channel and 2 cameras (2-view camera fusion)');end;if verbose == 1 || verbose == 2    disp(' ');end;jobCompleted = 0;disp(['processing time point ' num2str(timepoint, '%.6d')]);inputFolder  = [inputString '/SPM' num2str(specimen, '%.2d') '/TM' num2str(timepoint, '%.6d')];inputHeader  = ['SPM' num2str(specimen, '%.2d') '_TM' num2str(timepoint, '%.6d')];outputFolder = [outputString '.TM' num2str(timepoint, '%.6d') '_multiFused' outputID];outputHeader = [outputFolder '/SPM' num2str(specimen, '%.2d') '_TM' num2str(timepoint, '%.6d')];if verbose == 1 || verbose == 2    disp(' ');end;if ~isdir(outputFolder)    mkdir(outputFolder);end;switch processingMode    case 0        outputString = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d')];        primaryDataArray = cell(2, 2);    case 1        outputString = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d')];        primaryDataArray = cell(1, 2);    case 2        outputString = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d')];        primaryDataArray = cell(2, 1);end;switch inputType    case 0        inputExtension = '.klb';    case 1        inputExtension = '.jp2';    case 2        inputExtension = '.tif';end;switch outputType    case 0        outputExtension = '.klb';    case 1        outputExtension = '.jp2';    case 2        outputExtension = '.tif';end;save([outputString '.configuration.mat'], 'configuration');referenceMinIntensity = 0;if processingMode ~= 2        %% alignChannels.m        tic;        for camera = cameras        currentCamera = find(cameras == camera, 1);                sX = cropping{find(cameras == camera, 1)}(2) + 1;        eX = cropping{find(cameras == camera, 1)}(2) + cropping{find(cameras == camera, 1)}(4);        sY = cropping{find(cameras == camera, 1)}(1) + 1;        eY = cropping{find(cameras == camera, 1)}(1) + cropping{find(cameras == camera, 1)}(3);        sZ = cropping{find(cameras == camera, 1)}(5) + 1;        eZ = cropping{find(cameras == camera, 1)}(6) + 1;                xSize = eX - sX + 1;        ySize = eY - sY + 1;        zSize = eZ - sZ + 1;        threshold = round(xSize * ySize * zSize * fraction);                stackArray = cell(2, 1);        sliceArray = cell(2, 1);                for c = channels            if verbose == 2                disp('--');                disp(['processing camera ' num2str(camera) ' channel ' num2str(c)]);                disp('--');            end;                        currentChannel = find(channels == c, 1);                        header = [inputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(c, '%.2d')];            currentString = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(c, '%.2d')];                        stackName = [currentString '.stack' outputExtension];            gaussName = [currentString '.gauss' outputExtension];            mask3Name = [currentString '.mask3D' outputExtension];            mask2Name = [currentString '.mask2D' outputExtension];                        if verbose == 2                disp('reading image stack');            end;                        if exist(stackName, 'file') ~= 2 || enforceFlag(1)                inputName = [inputFolder '/' header inputExtension];                stackArray{currentChannel} = readImage(inputName);                if ~strcmp(class(stackArray{currentChannel}), 'uint16')                    stackArray{currentChannel} = uint16(stackArray{currentChannel});                end;                                if sum(cropping{find(cameras == camera, 1)}) > 0                    stackArray{currentChannel} = stackArray{currentChannel}(sX:eX, sY:eY, sZ:eZ);                else                    xSize = size(stackArray{currentChannel}, 1);                    ySize = size(stackArray{currentChannel}, 2);                    zSize = size(stackArray{currentChannel}, 3);                    threshold = round(xSize * ySize * zSize * fraction);                end;                                if ~reducedIO                    writeImage(stackArray{currentChannel}, stackName);                end;            else                stackArray{currentChannel} = readImage(stackName);                                if sum(cropping{find(cameras == camera, 1)}) == 0                    xSize = size(stackArray{currentChannel}, 1);                    ySize = size(stackArray{currentChannel}, 2);                    zSize = size(stackArray{currentChannel}, 3);                    threshold = round(xSize * ySize * zSize * fraction);                end;            end;                        if dataType == 0                                if exist(gaussName, 'file') ~= 2 || enforceFlag(2)                    if verbose == 2                        disp(['gauss convolution with kernel size ' num2str(kernelSize) ' and sigma ' num2str(kernelSigma)]);                    end;                                        kernelSizeArray  = [kernelSize  kernelSize  max(1, kernelSize / scaling)];                    kernelSigmaArray = [kernelSigma kernelSigma max(1, kernelSigma / scaling)];                                        if splitting > 1                        gaussStack = zeros(xSize, ySize, zSize, 'uint16');                                                splittingMargin = 2 * kernelSize;                                                for i = 1:splitting                            xSlabStart = max(1, round((i - 1) * xSize / splitting + 1 - splittingMargin));                            xSlabStop = min(xSize, round(i * xSize / splitting + splittingMargin));                            if preciseGauss                                convolvedSlab = uint16(imgaussianAnisotropy(double(stackArray{currentChannel}(xSlabStart:xSlabStop, :, :)), kernelSigmaArray, kernelSizeArray));                            else                                convolvedSlab = imgaussianAnisotropy(stackArray{currentChannel}(xSlabStart:xSlabStop, :, :), kernelSigmaArray, kernelSizeArray);                            end;                            if i == 1                                gaussStack(1:(xSlabStop - splittingMargin), :, :) = convolvedSlab(1:(end - splittingMargin), :, :);                            elseif i == splitting                                gaussStack((xSlabStart + splittingMargin):end, :, :) = convolvedSlab((1 + splittingMargin):end, :, :);                            else % i > 1 && i < splitting                                gaussStack((xSlabStart + splittingMargin):(xSlabStop - splittingMargin), :, :) = convolvedSlab((1 + splittingMargin):(end - splittingMargin), :, :);                            end;                            clear convolvedSlab;                        end;                    else                        if preciseGauss                            gaussStack = uint16(imgaussianAnisotropy(double(stack), kernelSigmaArray, kernelSizeArray));                        else                            gaussStack = imgaussianAnisotropy(stack, kernelSigmaArray, kernelSizeArray);                        end;                    end;                                        if ~reducedIO                        writeImage(gaussStack, gaussName);                    end;                else                    if verbose == 2                        disp(['reading gauss-convolved image stack with ' num2str(zSize) ' planes']);                    end;                    gaussStack = readImage(gaussName);                end;                                if exist(mask3Name, 'file') ~= 2 || enforceFlag(3)                    if maskMinimum(1) == 0                        intensityStatistics = zeros(splitting, 2);                        for i = 1:splitting                            xSlabStart = round((i - 1) * xSize / splitting + 1);                            xSlabStop  = round(i * xSize / splitting);                            temporaryArray = gaussStack(xSlabStart:xSlabStop, :, :);                            intensityStatistics(i, 1) = sum(temporaryArray(:));                            intensityStatistics(i, 2) = (xSlabStop - xSlabStart + 1) * ySize * zSize;                            if i == 1                                minIntensity = min(temporaryArray(:));                            else                                minIntensity = min(minIntensity, min(temporaryArray(:)));                            end;                        end;                        meanIntensity = sum(intensityStatistics(:, 1)) / sum(intensityStatistics(:, 2));                        clear temporaryArray intensityStatistics;                    else                        if maskMinimum(1) > 0                            minIntensity = prctile(gaussStack(1:maskMinimum(2):end), maskMinimum(1));                        end;                        intensityStatistics = zeros(splitting, 2);                        for i = 1:splitting                            xSlabStart = round((i - 1) * xSize / splitting + 1);                            xSlabStop  = round(i * xSize / splitting);                            temporaryArray = gaussStack(xSlabStart:xSlabStop, :, :);                            temporaryArray = temporaryArray(temporaryArray > minIntensity);                            intensityStatistics(i, 1) = sum(temporaryArray(:));                            intensityStatistics(i, 2) = size(temporaryArray, 1);                        end;                        meanIntensity = sum(intensityStatistics(:, 1)) / sum(intensityStatistics(:, 2));                        clear temporaryArray intensityStatistics;                    end;                                        level = minIntensity + (meanIntensity - minIntensity) * maskFactor;                                        referenceMinIntensity = max(referenceMinIntensity, minIntensity);                                        if verbose == 2                        if fraction > 0                            disp(['thresholding gauss-convolved image stack using level ' num2str(round(level)) ' and size ' num2str(threshold)]);                        else                            disp(['thresholding gauss-convolved image stack using level ' num2str(round(level))]);                        end;                    end;                    mask = gaussStack > level;                    if fraction > 0                        mask = bwareaopen(mask, threshold);                    end;                                        if ~reducedIO                        writeImage(uint16(mask), mask3Name);                    end;                else                    if verbose == 2                        disp(['reading thresholded image stack with ' num2str(zSize) ' planes']);                    end;                    mask = readImage(mask3Name);                end;                                if exist(mask2Name, 'file') ~= 2 || enforceFlag(4)                    if verbose == 2                        disp('computing stack slice mask');                    end;                                        sliceMask = zeros(xSize, zSize, 'uint16');                    for i = 1:splitting                        xSlabStart = round((i - 1) * xSize / splitting + 1);                        xSlabStop  = round(i * xSize / splitting);                        coordinateMask = repmat(1:ySize, [(xSlabStop - xSlabStart + 1) 1 size(mask, 3)]);                        coordinateMask(mask(xSlabStart:xSlabStop, :, :) == 0) = NaN;                        sliceMask(xSlabStart:xSlabStop, :) = uint16(round(squeeze(nanmean(coordinateMask, 2))));                    end;                                        clear coordinateMask;                                        writeImage(sliceMask, mask2Name);                else                    if verbose == 2                        disp('reading stack slice mask');                    end;                    sliceMask = readImage(mask2Name);                end;                                sliceArray{find(channels == c, 1)} = sliceMask;                                clear mask gaussStack;                            else % image volume has already been segmented during pre-processing                                if verbose == 2                    disp('reading stack slice mask and background information');                end;                                mask2Name = [inputFolder '/' header '.xzMask' inputExtension];                sliceArray{find(channels == c, 1)} = readImage(mask2Name);                                mask2Name = [currentString '.xzMask' outputExtension];                writeImage(sliceArray{find(channels == c, 1)}, mask2Name);                                minIntensityName = [inputFolder '/' header '.minIntensity.mat'];                load(minIntensityName, 'minIntensity');                referenceMinIntensity = max(referenceMinIntensity, minIntensity(1));                            end;                        if verbose == 2                disp(' ');            end;        end;                if verbose == 2            disp('--');            disp(['evaluating camera ' num2str(camera) ' results']);            disp('--');        end;                if verbose == 2            disp('determining average slicing topology');        end;                if maskFusion == 0            % consider only regions that exist in both masks            overlap = (sliceArray{1} > 0) & (sliceArray{2} > 0);            averageMask = uint16((double(sliceArray{1}) .* double(overlap) + double(sliceArray{2}) .* double(overlap)) ./ 2);        else            % consider regions that exist in either of the two masks            overlap = (sliceArray{1} > 0) & (sliceArray{2} > 0);            averageMask = uint16((double(sliceArray{1}) .* double(overlap) + double(sliceArray{2}) .* double(overlap)) ./ 2);            averageMask = averageMask + ...                uint16(double(sliceArray{1}) .* double(sliceArray{1} > 0) .* double(averageMask == 0)) + ...                uint16(double(sliceArray{2}) .* double(sliceArray{2} > 0) .* double(averageMask == 0));        end;                localAnomalies = sum(averageMask(:) > (ySize - blending(1))) + sum(averageMask(averageMask(:) ~= 0) < blending(1));        if localAnomalies > 0            if verbose == 2                disp(['removing ' num2str(localAnomalies) ' mask anomalies']);            end;                        averageMask(averageMask > (ySize - blending(1))) = 0;            averageMask(averageMask < blending(1)) = 0;        else            if verbose == 2                disp('no mask anomalies detected');            end;        end;                if fusionType == 1            if transitions(1) == 0                averageMask(averageMask > 0) = round(ySize / 2);            else                averageMask(averageMask > 0) = transitions(1);            end;        end;                averageMaskName = [outputHeader  '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.mask' outputExtension];        writeImage(averageMask, averageMaskName);                minMask = min(averageMask(averageMask > 0));        maxMask = max(averageMask(:));                lowerBound = double(minMask) - double(slabSizes(1));        if lowerBound < 1            lowerSlabSize = slabSizes(1) + lowerBound - 1;        else            lowerSlabSize = slabSizes(1);        end;                upperBound = double(maxMask) + double(slabSizes(1)) - double(ySize);        if upperBound > 0            upperSlabSize = slabSizes(1) - upperBound;        else            upperSlabSize = slabSizes(1);        end;                finalSlabSize = lowerSlabSize + upperSlabSize + 1;                dataSlice1 = zeros(xSize, zSize, finalSlabSize, 'uint16');        dataSlice2 = zeros(xSize, zSize, finalSlabSize, 'uint16');        for z = 1:zSize            for x = 1:xSize                if averageMask(x, z) > 0                    currentIndexArray = (averageMask(x, z) - lowerSlabSize):(averageMask(x, z) + upperSlabSize);                    dataSlice1(x, z, :) = stackArray{1}(x, currentIndexArray, z);                    dataSlice2(x, z, :) = stackArray{2}(x, currentIndexArray, z);                end;            end;        end;                dataSlice1Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.dataSlice' outputExtension];        dataSlice2Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.dataSlice' outputExtension];                if ~reducedIO || reducedIO == 2            writeImage(dataSlice1, dataSlice1Name);            writeImage(dataSlice2, dataSlice2Name);        end;                backgroundArray1 = dataSlice1(1:subSampling(1):end);        backgroundArray2 = dataSlice2(1:subSampling(1):end);        intensityOffset = prctile(cat(2, backgroundArray1(backgroundArray1 > 0), backgroundArray2(backgroundArray2 > 0)), percentile);        clear backgroundArray1 backgroundArray2;                dataSlice1 = dataSlice1 - intensityOffset;        dataSlice2 = dataSlice2 - intensityOffset;                subtractedSlice1Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.subtractedSlice' outputExtension];        subtractedSlice2Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.subtractedSlice' outputExtension];                if exist(subtractedSlice1Name, 'file') ~= 2 || exist(subtractedSlice2Name, 'file') ~= 2 || enforceFlag(5)            if medianFilter > 0                gaussFilterSizeArray  = [gaussFilter(1) max(1, gaussFilter(1) / scaling)];                gaussFilterSigmaArray = [gaussFilter(2) max(1, gaussFilter(2) / scaling)];                medianFilterArray = [medianFilter max(1, round(medianFilter / scaling))];                                for p = 1:finalSlabSize                    if gaussFilter(1) == 0                        dataSlice1(:, :, p) = dataSlice1(:, :, p) - medfilt2(dataSlice1(:, :, p), medianFilterArray, 'symmetric');                        dataSlice2(:, :, p) = dataSlice2(:, :, p) - medfilt2(dataSlice2(:, :, p), medianFilterArray, 'symmetric');                    else                        dataSlice1(:, :, p) = uint16(imgaussianAnisotropy(double(dataSlice1(:, :, p)), gaussFilterSigmaArray, gaussFilterSizeArray)) - medfilt2(dataSlice1(:, :, p), medianFilterArray, 'symmetric');                        dataSlice2(:, :, p) = uint16(imgaussianAnisotropy(double(dataSlice2(:, :, p)), gaussFilterSigmaArray, gaussFilterSizeArray)) - medfilt2(dataSlice2(:, :, p), medianFilterArray, 'symmetric');                    end;                end;            end;                        if ~reducedIO || reducedIO == 2                writeImage(dataSlice1, subtractedSlice1Name);                writeImage(dataSlice2, subtractedSlice2Name);            end;        else            if verbose == 2                disp('reading background-subtracted slices');            end;                        dataSlice1 = readImage(subtractedSlice1Name);            dataSlice2 = readImage(subtractedSlice2Name);        end;                transformationName = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformation.mat'];                if exist(transformationName, 'file') ~= 2 || enforceFlag(6)            if verbose == 2                disp('determining optimal transformation');            end;                        fun = @(x)transformChannel(x, double(dataSlice1), double(dataSlice2), scaling);            x0 = [0 0]; % initial point: x0(1) = z-offset, x0(2) = rotation in degrees            optionsOpt = optimset('Display', 'off', 'TolFun', 1e-12, 'TolX', 1e-3, 'GradObj', 'off', 'LargeScale', 'off');            stepSize = [1.0 0.1];                        if optimizer == 1                [xSol, fval, exitflag] = fminunc(fun, x0, optionsOpt);    % uses approximation of Newton method            elseif optimizer == 2                [xSol, fval, exitflag] = fminsearch(fun, x0, optionsOpt); % uses Nelder-Mead simplex (direct search) method, slower            elseif optimizer == 3                [xSol, fval, exitflag] = fminuncFA(fun, x0, stepSize);    % uses approximation of gradient descent (by Fernando Amat)            end;                        bestOffset   = xSol(1);            bestRotation = xSol(2);                        transformation = [scaling bestOffset bestRotation];                        save(transformationName, 'transformation');                    else            if verbose == 2                disp('reading optimal transformation');            end;                        load(transformationName);                        bestOffset   = transformation(2);            bestRotation = transformation(3);        end;                if verbose == 2            disp(['results: optimal z offset = ' num2str(bestOffset) ', optimal rotation angle = ' num2str(bestRotation)]);        end;                transformedSliceName = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformedSlice' outputExtension];                if exist(transformedSliceName, 'file') ~= 2            RR = [ cosd(bestRotation) sind(bestRotation);...                -sind(bestRotation) cosd(bestRotation)];            [XI ZI] = meshgrid(1:xSize, 1:zSize);            cc = [(xSize + 1) / 2.0 (zSize + 1) / 2.0];            XI = XI' - cc(1);            ZI = ZI' - cc(2);            XZaux = (RR * [XI(:) ZI(:) .* scaling]')';            XI = reshape(XZaux(:, 1) + cc(1), size(XI));            ZI = reshape(XZaux(:, 2) ./ scaling + cc(2), size(ZI));                        ZI = ZI - bestOffset;                        maskPos = find(XI < 1 | ZI < 1 | XI > xSize | ZI > zSize);            maskRT = true(xSize, zSize);            maskRT(maskPos) = false;                        transformedSlice = repmat(maskRT, [1 1 size(dataSlice2, 3)]) .* fInterpolate(double(dataSlice2), ZI, XI, 'cubic');                        if ~reducedIO || reducedIO == 2                writeImage(uint16(transformedSlice), transformedSliceName);            end;        else            transformedSlice = readImage(transformedSliceName);        end;                if verbose == 2            disp(' ');        end;                if verbose == 2            disp('--');            disp(['transforming camera ' num2str(camera) ' data']);            disp('--');        end;                primaryDataArray{currentCamera, 1} = stackArray{1};        dataStack2 = stackArray{2};                clear stackArray;                transformedStackName = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformedStack' outputExtension];                if exist(transformedStackName, 'file') ~= 2 || enforceFlag(7)            if verbose == 2                disp('transforming image stack');            end;                        RR = [ cosd(bestRotation) sind(bestRotation);...                -sind(bestRotation) cosd(bestRotation)];            [XI ZI] = meshgrid(1:xSize, 1:zSize);            cc = [(xSize + 1) / 2.0 (zSize + 1) / 2.0];            XI = XI' - cc(1);            ZI = ZI' - cc(2);            XZaux = (RR * [XI(:) ZI(:) .* scaling]')';            XI = reshape(XZaux(:, 1) + cc(1), size(XI));            ZI = reshape(XZaux(:, 2) ./ scaling + cc(2), size(ZI));                        ZI = ZI - bestOffset;                        maskPos = find(XI < 1 | ZI < 1 | XI > xSize | ZI > zSize);            maskTR = true(xSize, zSize);            maskTR(maskPos) = false;                        dataStack2 = permute(dataStack2, [1 3 2]);                        primaryDataArray{currentCamera, 2} = zeros(xSize, zSize, ySize, 'uint16');            for i = 1:splitting                ySlabStart = round((i - 1) * ySize / splitting + 1);                ySlabStop  = round(i * ySize / splitting);                primaryDataArray{currentCamera, 2}(:, :, ySlabStart:ySlabStop) = ...                    uint16(bsxfun(@times, maskTR, fInterpolate(double(dataStack2(:, :, ySlabStart:ySlabStop)), ZI, XI, 'cubic')));            end;                        primaryDataArray{currentCamera, 2} = permute(primaryDataArray{currentCamera, 2}, [1 3 2]);                        if ~reducedIO                writeImage(primaryDataArray{currentCamera, 2}, transformedStackName);            end;        else            if verbose == 2                disp('reading transformed stack');            end;                        primaryDataArray{currentCamera, 2} = readImage(transformedStackName);        end;                if verbose == 2            disp(' ');        end;    end;        referenceMinIntensityName = [outputString '.referenceMinIntensity.mat'];    save(referenceMinIntensityName, 'referenceMinIntensity');        time = toc;    if verbose == 1 || verbose == 2        disp(['*** channel alignment completed in ' num2str(floor(floor(time / 60) / 60), '%.2d') ':' num2str(mod(floor(time / 60), 60), '%.2d') ':' num2str(round(mod(time, 60)), '%.2d')]);    end;        if verbose == 2        disp(' ');    end;        %% fuseChannels.m        tic;        for camera = cameras        if verbose == 2            disp('--');            disp(['processing camera ' num2str(camera) ' data']);            disp('--');        end;                currentCamera = find(cameras == camera, 1);                leftFlag = leftFlags(find(cameras == camera, 1));                xSize = size(primaryDataArray{currentCamera, 1}, 1);        ySize = size(primaryDataArray{currentCamera, 1}, 2);        zSize = size(primaryDataArray{currentCamera, 1}, 3);                averageMaskName = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.fusionMask' outputExtension];                if exist(averageMaskName, 'file') ~= 2 || enforceFlag(8)                        sliceArray = cell(2, 1);                        if dataType == 1                                mask2Name = [inputFolder '/' inputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.xzMask' inputExtension];                sliceArray{1} = readImage(mask2Name);                                mask2Name = [inputFolder '/' inputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.xzMask' inputExtension];                sliceArray{2} = readImage(mask2Name);                                transformationName = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformation.mat'];                load(transformationName, 'transformation');                bestOffset   = transformation(2);                bestRotation = transformation(3);                                RR = [ cosd(bestRotation) sind(bestRotation);...                    -sind(bestRotation) cosd(bestRotation)];                [XI ZI] = meshgrid(1:xSize, 1:zSize);                cc = [(xSize + 1) / 2.0 (zSize + 1) / 2.0];                XI = XI' - cc(1);                ZI = ZI' - cc(2);                XZaux = (RR * [XI(:) ZI(:) .* scaling]')';                XI = reshape(XZaux(:, 1) + cc(1), size(XI));                ZI = reshape(XZaux(:, 2) ./ scaling + cc(2), size(ZI));                                ZI = ZI - bestOffset;                                maskPos = find(XI < 1 | ZI < 1 | XI > xSize | ZI > zSize);                maskRT = true(xSize, zSize);                maskRT(maskPos) = false;                                sliceArray{2} = uint16(repmat(maskRT, [1 1 size(sliceArray{2}, 3)]) .* fInterpolate(double(sliceArray{2}), ZI, XI, 'nearest'));                                transformedMask2Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.xzMaskTransformed' outputExtension];                writeImage(sliceArray{2}, transformedMask2Name);                            else                                mask2Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.mask2D' outputExtension];                sliceArray{1} = readImage(mask2Name);                                transformedGaussName = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformedGauss' outputExtension];                                if exist(transformedGaussName, 'file') ~= 2 || enforceFlag(9)                    if verbose == 2                        disp(['gauss convolution with kernel size ' num2str(kernelSize) ' and sigma ' num2str(kernelSigma)]);                    end;                                        kernelSizeArray  = [kernelSize  kernelSize  max(1, kernelSize / scaling)];                    kernelSigmaArray = [kernelSigma kernelSigma max(1, kernelSigma / scaling)];                                        if splitting > 1                        gaussStack = zeros(xSize, ySize, zSize, 'uint16');                                                splittingMargin = 2 * kernelSize;                                                for i = 1:splitting                            xSlabStart = max(1, round((i - 1) * xSize / splitting + 1 - splittingMargin));                            xSlabStop = min(xSize, round(i * xSize / splitting + splittingMargin));                            if preciseGauss                                convolvedSlab = uint16(imgaussianAnisotropy(double(primaryDataArray{currentCamera, 2}(xSlabStart:xSlabStop, :, :)), kernelSigmaArray, kernelSizeArray));                            else                                convolvedSlab = imgaussianAnisotropy(primaryDataArray{currentCamera, 2}(xSlabStart:xSlabStop, :, :), kernelSigmaArray, kernelSizeArray);                            end;                            if i == 1                                gaussStack(1:(xSlabStop - splittingMargin), :, :) = convolvedSlab(1:(end - splittingMargin), :, :);                            elseif i == splitting                                gaussStack((xSlabStart + splittingMargin):end, :, :) = convolvedSlab((1 + splittingMargin):end, :, :);                            else % i > 1 && i < splitting                                gaussStack((xSlabStart + splittingMargin):(xSlabStop - splittingMargin), :, :) = convolvedSlab((1 + splittingMargin):(end - splittingMargin), :, :);                            end;                            clear convolvedSlab;                        end;                    else                        if preciseGauss                            gaussStack = uint16(imgaussianAnisotropy(double(primaryDataArray{currentCamera, 2}), kernelSigmaArray, kernelSizeArray));                        else                            gaussStack = imgaussianAnisotropy(primaryDataArray{currentCamera, 2}, kernelSigmaArray, kernelSizeArray);                        end;                    end;                                        if ~reducedIO                        writeImage(gaussStack, transformedGaussName);                    end;                else                    if verbose == 2                        disp(['reading gauss-convolved image stack with ' num2str(zSize) ' planes']);                    end;                    gaussStack = readImage(transformedGaussName);                end;                                transformedMask3Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(c, '%.2d') '.transformedMask3D' outputExtension];                                if exist(transformedMask3Name, 'file') ~= 2 || enforceFlag(10)                    intensityStatistics = zeros(splitting, 2);                    for i = 1:splitting                        xSlabStart = round((i - 1) * xSize / splitting + 1);                        xSlabStop  = round(i * xSize / splitting);                        temporaryArray = gaussStack(xSlabStart:xSlabStop, :, :);                        temporaryArray = temporaryArray(temporaryArray > 0);                        intensityStatistics(i, 1) = sum(temporaryArray);                        intensityStatistics(i, 2) = size(temporaryArray, 1);                    end;                    meanIntensity = sum(intensityStatistics(:, 1)) / sum(intensityStatistics(:, 2));                    clear temporaryArray;                                        minIntensity = referenceMinIntensity;                    level = minIntensity + (meanIntensity - minIntensity) * maskFactor;                                        if verbose == 2                        if fraction > 0                            disp(['thresholding gauss-convolved image stack using level ' num2str(round(level)) ' and size ' num2str(threshold)]);                        else                            disp(['thresholding gauss-convolved image stack using level ' num2str(round(level))]);                        end;                    end;                    mask = gaussStack > level;                    if fraction > 0                        mask = bwareaopen(mask, threshold);                    end;                                        if ~reducedIO                        writeJStack(uint16(mask), transformedMask3Name);                    end;                else                    if verbose == 2                        disp(['reading thresholded image stack with ' num2str(zSize) ' planes']);                    end;                    mask = readImage(transformedMask3Name);                end;                                transformedMask2Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(c, '%.2d') '.transformedMask2D' outputExtension];                                if exist(transformedMask2Name, 'file') ~= 2 || enforceFlag(11)                    if verbose == 2                        disp('computing stack slice mask');                    end;                    sliceMask = zeros(xSize, zSize, 'uint16');                    for i = 1:splitting                        xSlabStart = round((i - 1) * xSize / splitting + 1);                        xSlabStop  = round(i * xSize / splitting);                        coordinateMask = repmat(1:ySize, [(xSlabStop - xSlabStart + 1) 1 size(mask, 3)]);                        coordinateMask(mask(xSlabStart:xSlabStop, :, :) == 0) = NaN;                        sliceMask(xSlabStart:xSlabStop, :) = uint16(round(squeeze(nanmean(coordinateMask, 2))));                    end;                                        clear coordinateMask;                                        writeImage(sliceMask, transformedMask2Name);                end;                                sliceArray{2} = sliceMask;                                clear mask sliceMask;                            end;                        if verbose == 2                disp('determining average slicing topology');            end;                        if maskFusion == 0                % consider only regions that exist in both masks                overlap = (sliceArray{1} > 0) & (sliceArray{2} > 0);                averageMask = uint16((double(sliceArray{1}) .* double(overlap) + double(sliceArray{2}) .* double(overlap)) ./ 2);            else                % consider regions that exist in either of the two masks                overlap = (sliceArray{1} > 0) & (sliceArray{2} > 0);                averageMask = uint16((double(sliceArray{1}) .* double(overlap) + double(sliceArray{2}) .* double(overlap)) ./ 2);                averageMask = averageMask + ...                    uint16(double(sliceArray{1}) .* double(sliceArray{1} > 0) .* double(averageMask == 0)) + ...                    uint16(double(sliceArray{2}) .* double(sliceArray{2} > 0) .* double(averageMask == 0));            end;                        localAnomalies = sum(averageMask(:) > (ySize - blending(1))) + sum(averageMask(averageMask(:) ~= 0) < blending(1));            if localAnomalies > 0                if verbose == 2                    disp(['removing ' num2str(localAnomalies) ' mask anomalies']);                end;                                averageMask(averageMask > (ySize - blending(1))) = 0;                averageMask(averageMask < blending(1)) = 0;            else                if verbose == 2                    disp('no mask anomalies detected');                end;            end;                        if fusionType == 1                if transitions(1) == 0                    averageMask(averageMask > 0) = round(ySize / 2);                else                    averageMask(averageMask > 0) = transitions(1);                end;            end;                        if padding(1) == 1                averageMask(averageMask == 0) = round(ySize / 2);            elseif padding(1) == 2                binaryMask = averageMask > 0;                dilatedMask = imdilate(binaryMask, strel('disk', padding(2)));                averageMask(~dilatedMask) = round(ySize / 2);                                [A, B] = meshgrid(1:zSize, 1:xSize);                foregroundSlots = find(averageMask > 0);                transitionSlots = find(averageMask == 0);                f = scatteredInterpolant(A(foregroundSlots), B(foregroundSlots), double(averageMask(foregroundSlots)), 'natural');                transitionValues = f(A(transitionSlots), B(transitionSlots));                averageMask(transitionSlots) = transitionValues;                averageMask(averageMask < blending(1)) = blending(1);                averageMask(averageMask > (ySize - blending(1))) = (ySize - blending(1));            end;                        writeImage(averageMask, averageMaskName);        else            if verbose == 2                disp('reading final average mask');            end;                        averageMask = readImage(averageMaskName);        end;                if correction(1) ~= 0            if dataType == 1                minIntensityName = [inputFolder '/' inputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.minIntensity.mat'];                load(minIntensityName, 'minIntensity');                backgroundIntensity1 = minIntensity(end);                                minIntensityName = [inputFolder '/' inputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.minIntensity.mat'];                load(minIntensityName, 'minIntensity');                backgroundIntensity2 = minIntensity(end);            else                backgroundArray1 = primaryDataArray{currentCamera, 1}(1:subSampling(2):end);                backgroundArray2 = primaryDataArray{currentCamera, 2}(1:subSampling(2):end);                background = prctile(cat(2, backgroundArray1(backgroundArray1 > 0), backgroundArray2(backgroundArray2 > 0)), percentile);                clear backgroundArray1 backgroundArray2;            end;                        if correction(1) == 1                if verbose == 2                    disp('analyzing intensity difference');                end;                                minMask = min(averageMask(averageMask > 0));                maxMask = max(averageMask(:));                                lowerBound = double(minMask) - double(intSizes(1));                if lowerBound < 1                    lowerSlabSize = intSizes(1) + lowerBound - 1;                else                    lowerSlabSize = intSizes(1);                end;                                upperBound = double(maxMask) + double(intSizes(1)) - double(ySize);                if upperBound > 0                    upperSlabSize = intSizes(1) - upperBound;                else                    upperSlabSize = intSizes(1);                end;                                finalSlabSize = lowerSlabSize + upperSlabSize + 1;                                dataSlice1 = zeros(xSize, zSize, finalSlabSize, 'uint16');                dataSlice2 = zeros(xSize, zSize, finalSlabSize, 'uint16');                for z = 1:zSize                    for x = 1:xSize                        if averageMask(x, z) > 0                            currentIndexArray = (averageMask(x, z) - lowerSlabSize):(averageMask(x, z) + upperSlabSize);                            dataSlice1(x, z, :) = primaryDataArray{currentCamera, 1}(x, currentIndexArray, z);                            dataSlice2(x, z, :) = primaryDataArray{currentCamera, 2}(x, currentIndexArray, z);                        end;                    end;                end;                                if dataType == 1                    dataSlice1 = dataSlice1 - backgroundIntensity1;                    dataSlice2 = dataSlice2 - backgroundIntensity2;                else                    dataSlice1 = dataSlice1 - background;                    dataSlice2 = dataSlice2 - background;                end;                                dataSlice1Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.fusionDataSlice' outputExtension];                dataSlice2Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.fusionDataSlice' outputExtension];                                if ~reducedIO || reducedIO == 2                    writeImage(dataSlice1, dataSlice1Name);                    writeImage(dataSlice2, dataSlice2Name);                end;                                intensityList1 = double(dataSlice1(:));                intensitySum1 = sum(intensityList1(intensityList1 > 0));                intensityList2 = double(dataSlice2(:));                intensitySum2 = sum(intensityList2(intensityList2 > 0));                                if intensitySum1 > intensitySum2                    correctionFactor = intensitySum1 / intensitySum2;                    correctionFlag = 2;                else                    correctionFactor = intensitySum2 / intensitySum1;                    correctionFlag = 1;                end;                                if dataType == 1                    intensityCorrection = [double(backgroundIntensity1) double(backgroundIntensity2) double(intensitySum1) double(intensitySum2) double(correctionFactor) double(correctionFlag)];                else                    intensityCorrection = [double(background) double(intensitySum1) double(intensitySum2) double(correctionFactor) double(correctionFlag)];                end;                intensityCorrectionName = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.intensityCorrection.mat'];                save(intensityCorrectionName, 'intensityCorrection');            else                if correction(3) > 1                    correctionFactor = correction(3);                    correctionFlag = 2;                else                    correctionFactor = 1 / correction(3);                    correctionFlag = 1;                end;            end;                        correctedStack1Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.correctedStack' outputExtension];            correctedStack2Name = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(2), '%.2d') '.correctedStack' outputExtension];                        if exist(correctedStack1Name, 'file') ~= 2 || exist(correctedStack2Name, 'file') ~= 2 || enforceFlag(12)                if verbose == 2                    disp('correcting image stacks');                end;                                if dataType == 1                    primaryDataArray{currentCamera, 1} = primaryDataArray{currentCamera, 1} - backgroundIntensity1;                    primaryDataArray{currentCamera, 1}(primaryDataArray{currentCamera, 1} < 0) = 0;                    primaryDataArray{currentCamera, 2} = primaryDataArray{currentCamera, 2} - backgroundIntensity2;                    primaryDataArray{currentCamera, 2}(primaryDataArray{currentCamera, 2} < 0) = 0;                else                    primaryDataArray{currentCamera, 1} = primaryDataArray{currentCamera, 1} - background;                    primaryDataArray{currentCamera, 1}(primaryDataArray{currentCamera, 1} < 0) = 0;                    primaryDataArray{currentCamera, 2} = primaryDataArray{currentCamera, 2} - background;                    primaryDataArray{currentCamera, 2}(primaryDataArray{currentCamera, 2} < 0) = 0;                end;                                if correctionFlag == 1                    primaryDataArray{currentCamera, 1} = primaryDataArray{currentCamera, 1} .* correctionFactor;                else                    primaryDataArray{currentCamera, 2} = primaryDataArray{currentCamera, 2} .* correctionFactor;                end;                                if ~reducedIO                    writeImage(primaryDataArray{currentCamera, 1}, correctedStack1Name);                    writeImage(primaryDataArray{currentCamera, 2}, correctedStack2Name);                end;            else                if verbose == 2                    disp('reading intensity-corrected stacks');                end;                                primaryDataArray{currentCamera, 1} = readImage(correctedStack1Name);                primaryDataArray{currentCamera, 2} = readImage(correctedStack2Name);            end;        else            if verbose == 2                disp('skipping intensity correction');            end;        end;                if fusionType == 0 || fusionType == 1            stitchedStackName = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.stitchedStack' outputExtension];                        if exist(stitchedStackName, 'file') ~= 2 || enforceFlag(13)                if verbose == 2                    disp('stitching corrected stacks');                end;                                channelMask = bsxfun(@le, reshape(uint16(1:ySize), [1, ySize, 1]), reshape(averageMask, [xSize, 1, zSize]));                if leftFlag == 1                    fusedStack = bsxfun(@times, uint16(reshape(averageMask, [xSize 1 zSize]) > 0), primaryDataArray{currentCamera, 2});                    fusedStack(channelMask) = primaryDataArray{currentCamera, 1}(channelMask);                else                    fusedStack = bsxfun(@times, uint16(reshape(averageMask, [xSize 1 zSize]) > 0), primaryDataArray{currentCamera, 1});                    fusedStack(channelMask) = primaryDataArray{currentCamera, 2}(channelMask);                end;                clear channelMask;                                if ~reducedIO                    writeImage(fusedStack, stitchedStackName);                end;            else                if verbose == 2                    disp('reading stitched stack');                end;                                fusedStack = readImage(stitchedStackName);            end;        end;                fusedStackName = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.fusedStack' outputExtension];                if exist(fusedStackName, 'file') ~= 2 || enforceFlag(14)            if fusionType == 0 || fusionType == 1                if verbose == 2                    disp('blending corrected stacks');                end;                                weighting1Left = 1:((0.5 - 1) / (blending(1) - 1)):0.5; % dominant fraction                weighting2Left = 0:((0.5 - 0) / (blending(1) - 1)):0.5; % fading fraction                                weighting1Right = 0.5:((1 - 0.5) / (blending(1) - 1)):1; % dominant fraction                weighting2Right = 0.5:((0 - 0.5) / (blending(1) - 1)):0; % fading fraction                                if leftFlag == 1                    for z = 1:zSize                        for x = 1:xSize                            if averageMask(x, z) > 0                                array1Left = double(primaryDataArray{currentCamera, 1}(x, (averageMask(x, z) - blending(1) + 1):averageMask(x, z), z));                                array2Left = double(primaryDataArray{currentCamera, 2}(x, (averageMask(x, z) - blending(1) + 1):averageMask(x, z), z));                                array1Right = double(primaryDataArray{currentCamera, 1}(x, (averageMask(x, z) + 1):(averageMask(x, z) + blending(1)), z));                                array2Right = double(primaryDataArray{currentCamera, 2}(x, (averageMask(x, z) + 1):(averageMask(x, z) + blending(1)), z));                                fusedStack(x, (averageMask(x, z) - blending(1) + 1):averageMask(x, z), z) = uint16(array1Left .* weighting1Left + array2Left .* weighting2Left);                                fusedStack(x, (averageMask(x, z) + 1):(averageMask(x, z) + blending(1)), z) = uint16(array1Right .* weighting2Right + array2Right .* weighting1Right);                            end;                        end;                    end;                else                    for z = 1:zSize                        for x = 1:xSize                            if averageMask(x, z) > 0                                array1Left = double(primaryDataArray{currentCamera, 1}(x, (averageMask(x, z) - blending(1) + 1):averageMask(x, z), z));                                array2Left = double(primaryDataArray{currentCamera, 2}(x, (averageMask(x, z) - blending(1) + 1):averageMask(x, z), z));                                array1Right = double(primaryDataArray{currentCamera, 1}(x, (averageMask(x, z) + 1):(averageMask(x, z) + blending(1)), z));                                array2Right = double(primaryDataArray{currentCamera, 2}(x, (averageMask(x, z) + 1):(averageMask(x, z) + blending(1)), z));                                fusedStack(x, (averageMask(x, z) - blending(1) + 1):averageMask(x, z), z) = uint16(array1Left .* weighting2Left + array2Left .* weighting1Left);                                fusedStack(x, (averageMask(x, z) + 1):(averageMask(x, z) + blending(1)), z) = uint16(array1Right .* weighting1Right + array2Right .* weighting2Right);                            end;                        end;                    end;                end;            elseif fusionType == 2                if verbose == 2                    disp('performing wavelet fusion of corrected stacks');                end;                                fusedStack = zeros(xSize, ySize, zSize, 'uint16');                for z = 1:zSize                    fusedStack(:, :, z) = uint16(wfusimg(primaryDataArray{currentCamera, 1}(:, :, z), primaryDataArray{currentCamera, 2}(:, :, z), 'db4', 5, 'mean', 'max'));                end;            elseif fusionType == 3                if verbose == 2                    disp('performing averaging of corrected stacks');                end;                                fusedStack = zeros(xSize, ySize, zSize, 'uint16');                for z = 1:zSize                    fusedStack(:, :, z) = (primaryDataArray{currentCamera, 1}(:, :, z) + primaryDataArray{currentCamera, 2}(:, :, z)) ./ 2;                end;            end;                        if (processingMode == 0 && ~reducedIO) || processingMode == 1                writeImage(fusedStack, fusedStackName);            end;                        if processingMode == 1                currentString = [outputHeader '_CM' num2str(camera, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d')];                                fusedStackProjXYName = [currentString '.fusedStack_xyProjection' outputExtension];                fusedStackProjXZName = [currentString '.fusedStack_xzProjection' outputExtension];                fusedStackProjYZName = [currentString '.fusedStack_yzProjection' outputExtension];                                writeImage(max(fusedStack, [], 3), fusedStackProjXYName);                writeImage(squeeze(max(fusedStack, [], 2)), fusedStackProjXZName);                writeImage(squeeze(max(fusedStack, [], 1)), fusedStackProjYZName);            end;        else            if verbose == 2                disp('reading fused stack');            end;                        fusedStack = readImage(fusedStackName);        end;                if processingMode == 0            primaryDataArray{currentCamera, 1} = fusedStack;            primaryDataArray{currentCamera, 2} = [];                        clear fusedStack;        end;                if verbose == 2            disp(' ');        end;    end;        time = toc;    if verbose == 1        disp(['***    channel fusion completed in ' num2str(floor(floor(time / 60) / 60), '%.2d') ':' num2str(mod(floor(time / 60), 60), '%.2d') ':' num2str(round(mod(time, 60)), '%.2d')]);    elseif verbose == 2        disp(['*** channel fusion completed in ' num2str(floor(floor(time / 60) / 60), '%.2d') ':' num2str(mod(floor(time / 60), 60), '%.2d') ':' num2str(round(mod(time, 60)), '%.2d')]);    end;        if verbose == 2        disp(' ');    end;end;if processingMode ~= 1        %% alignCameras.m        tic;        gaussArray  = cell(2, 1);    sliceArray  = cell(2, 1);        scores = zeros(length(xOffsets), length(yOffsets), 3);    intensities = zeros(length(xOffsets), length(yOffsets));        if processingMode == 2        meanIntensities = zeros(2, 1);    end;        for x = 1:length(xOffsets)        for y = 1:length(yOffsets)            scores(x, y, 1) = xOffsets(x);            scores(x, y, 2) = yOffsets(y);        end;    end;        for c = cameras        if verbose == 2            disp('--');            disp(['preparing data for camera ' num2str(c)]);            disp('--');        end;                currentCamera = find(cameras == c, 1);                if verbose == 2            disp('reading pre-fused stacks');        end;                if processingMode == 2            sX = cropping{currentCamera}(2) + 1;            eX = cropping{currentCamera}(2) + cropping{currentCamera}(4);            sY = cropping{currentCamera}(1) + 1;            eY = cropping{currentCamera}(1) + cropping{currentCamera}(3);            sZ = cropping{currentCamera}(5) + 1;            eZ = cropping{currentCamera}(6) + 1;                        xSize = eX - sX + 1;            ySize = eY - sY + 1;            zSize = eZ - sZ + 1;                        header = [inputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d')];            stackName = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.stack' outputExtension];                        if verbose == 2                disp('reading image stack');            end;                        if exist(stackName, 'file') ~= 2 || enforceFlag(1)                inputName = [inputFolder '/' header inputExtension];                primaryDataArray{currentCamera} = readImage(inputName);                if ~strcmp(class(primaryDataArray{currentCamera}), 'uint16')                    primaryDataArray{currentCamera} = uint16(primaryDataArray{currentCamera});                end;                                if sum(cropping{currentCamera}) > 0                    primaryDataArray{currentCamera} = primaryDataArray{currentCamera}(sX:eX, sY:eY, sZ:eZ);                else                    xSize = size(primaryDataArray{currentCamera}, 1);                    ySize = size(primaryDataArray{currentCamera}, 2);                    zSize = size(primaryDataArray{currentCamera}, 3);                    threshold = round(xSize * ySize * zSize * fraction);                end;                                if ~reducedIO                    writeImage(primaryDataArray{currentCamera}, stackName);                end;            else                primaryDataArray{currentCamera} = readImage(stackName);                                if sum(cropping{currentCamera}) == 0                    xSize = size(primaryDataArray{currentCamera}, 1);                    ySize = size(primaryDataArray{currentCamera}, 2);                    zSize = size(primaryDataArray{currentCamera}, 3);                    threshold = round(xSize * ySize * zSize * fraction);                end;            end;        end;                if flipHFlag && c == cameras(end)            for z = 1:zSize                primaryDataArray{currentCamera, 1}(:, :, z) = fliplr(primaryDataArray{currentCamera, 1}(:, :, z));            end;        end;                if flipVFlag && c == cameras(end)            for z = 1:zSize                primaryDataArray{currentCamera, 1}(:, :, z) = flipud(primaryDataArray{currentCamera, 1}(:, :, z));            end;        end;                if dataType == 0                        if processingMode == 0                gaussName = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.gauss' outputExtension];            else                gaussName = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.gauss' outputExtension];            end;                        if exist(gaussName, 'file') ~= 2 || enforceFlag(15)                if verbose == 2                    disp(['gauss convolution with kernel size ' num2str(kernelSize) ' and sigma ' num2str(kernelSigma)]);                end;                                kernelSizeArray  = [kernelSize  kernelSize  max(1, kernelSize / scaling)];                kernelSigmaArray = [kernelSigma kernelSigma max(1, kernelSigma / scaling)];                                if splitting > 1                    gaussArray{currentCamera} = zeros(xSize, ySize, zSize, 'uint16');                                        splittingMargin = 2 * kernelSize;                                        for i = 1:splitting                        xSlabStart = max(1, round((i - 1) * xSize / splitting + 1 - splittingMargin));                        xSlabStop = min(xSize, round(i * xSize / splitting + splittingMargin));                        if preciseGauss                            convolvedSlab = uint16(imgaussianAnisotropy(double(primaryDataArray{currentCamera, 1}(xSlabStart:xSlabStop, :, :)), kernelSigmaArray, kernelSizeArray));                        else                            convolvedSlab = imgaussianAnisotropy(primaryDataArray{currentCamera, 1}(xSlabStart:xSlabStop, :, :), kernelSigmaArray, kernelSizeArray);                        end;                        if i == 1                            gaussArray{currentCamera}(1:(xSlabStop - splittingMargin), :, :) = convolvedSlab(1:(end - splittingMargin), :, :);                        elseif i == splitting                            gaussArray{currentCamera}((xSlabStart + splittingMargin):end, :, :) = convolvedSlab((1 + splittingMargin):end, :, :);                        else % i > 1 && i < splitting                            gaussArray{currentCamera}((xSlabStart + splittingMargin):(xSlabStop - splittingMargin), :, :) = convolvedSlab((1 + splittingMargin):(end - splittingMargin), :, :);                        end;                        clear convolvedSlab;                    end;                else                    if preciseGauss                        gaussArray{currentCamera} = uint16(imgaussianAnisotropy(double(primaryDataArray{currentCamera, 1}), kernelSigmaArray, kernelSizeArray));                    else                        gaussArray{currentCamera} = imgaussianAnisotropy(primaryDataArray{currentCamera, 1}, kernelSigmaArray, kernelSizeArray);                    end;                end;                                if ~reducedIO                    writeImage(gaussArray{currentCamera}, gaussName);                end;            else                if verbose == 2                    disp(['reading gauss-convolved image stack with ' num2str(zSize) ' planes']);                end;                gaussArray{currentCamera} = readImage(gaussName);            end;                        if processingMode == 2                if maskMinimum(1) == 0                    for i = 1:splitting                        xSlabStart = round((i - 1) * xSize / splitting + 1);                        xSlabStop  = round(i * xSize / splitting);                        temporaryArray = gaussArray{currentCamera}(xSlabStart:xSlabStop, :, :);                        if maskMinimum(1) == 0                            if i == 1                                minIntensity = min(temporaryArray(:));                            else                                minIntensity = min(minIntensity, min(temporaryArray(:)));                            end;                        end;                    end;                    clear temporaryArray;                else                    minIntensity = prctile(gaussArray{currentCamera}(1:maskMinimum(2):end), maskMinimum(1));                end;                                referenceMinIntensity = max(referenceMinIntensity, minIntensity);            end;                    else % image volume has already been segmented during pre-processing                        if processingMode == 2                if verbose == 2                    disp('reading stack slice mask and background information');                end;                                mask2Name = [inputFolder '/' header '.xyMask' inputExtension];                                if flipHFlag && c == cameras(end)                    sliceArray{find(cameras == c, 1)} = fliplr(readImage(mask2Name));                else                    sliceArray{find(cameras == c, 1)} = readImage(mask2Name);                end;                                if flipVFlag && c == cameras(end)                    sliceArray{find(cameras == c, 1)} = flipud(sliceArray{find(cameras == c, 1)});                end;                                mask2Name = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.xyMask' outputExtension];                writeImage(sliceArray{find(cameras == c, 1)}, mask2Name);                                minIntensityName = [inputFolder '/' header '.minIntensity.mat'];                load(minIntensityName, 'minIntensity');                referenceMinIntensity = max(referenceMinIntensity, minIntensity(1));            else                if verbose == 2                    disp('estimating stack slice mask and background information');                end;                                if padding(1) == 0                    mask2Name = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.xyMask' outputExtension];                    mask = primaryDataArray{currentCamera} > 0;                                        sliceMask = zeros(xSize, ySize, 'uint16');                    for i = 1:splitting                        xSlabStart = round((i - 1) * xSize / splitting + 1);                        xSlabStop  = round(i * xSize / splitting);                        coordinateMask = repmat(reshape(1:zSize, [1 1 zSize]), [(xSlabStop - xSlabStart + 1) size(mask, 2) 1]);                        coordinateMask(mask(xSlabStart:xSlabStop, :, :) == 0) = NaN;                        sliceMask(xSlabStart:xSlabStop, :) = uint16(round(squeeze(nanmean(coordinateMask, 3))));                    end;                                        clear mask coordinateMask;                else % padding(1) == 1 || padding(1) == 2                    mask2Name = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.xyMask' outputExtension];                                        kernelSizeArray  = [kernelSize  kernelSize  max(1, kernelSize / scaling)];                    kernelSigmaArray = [kernelSigma kernelSigma max(1, kernelSigma / scaling)];                                        if splitting > 1                        gaussArray{currentCamera} = zeros(xSize, ySize, zSize, 'uint16');                                                splittingMargin = 2 * kernelSize;                                                for i = 1:splitting                            xSlabStart = max(1, round((i - 1) * xSize / splitting + 1 - splittingMargin));                            xSlabStop = min(xSize, round(i * xSize / splitting + splittingMargin));                            if preciseGauss                                convolvedSlab = uint16(imgaussianAnisotropy(double(primaryDataArray{currentCamera}(xSlabStart:xSlabStop, :, :)), kernelSigmaArray, kernelSizeArray));                            else                                convolvedSlab = imgaussianAnisotropy(primaryDataArray{currentCamera}(xSlabStart:xSlabStop, :, :), kernelSigmaArray, kernelSizeArray);                            end;                            if i == 1                                gaussArray{currentCamera}(1:(xSlabStop - splittingMargin), :, :) = convolvedSlab(1:(end - splittingMargin), :, :);                            elseif i == splitting                                gaussArray{currentCamera}((xSlabStart + splittingMargin):end, :, :) = convolvedSlab((1 + splittingMargin):end, :, :);                            else % i > 1 && i < splitting                                gaussArray{currentCamera}((xSlabStart + splittingMargin):(xSlabStop - splittingMargin), :, :) = convolvedSlab((1 + splittingMargin):(end - splittingMargin), :, :);                            end;                            clear convolvedSlab;                        end;                    else                        if preciseGauss                            gaussArray{currentCamera} = uint16(imgaussianAnisotropy(double(primaryDataArray{currentCamera}), kernelSigmaArray, kernelSizeArray));                        else                            gaussArray{currentCamera} = imgaussianAnisotropy(primaryDataArray{currentCamera}, kernelSigmaArray, kernelSizeArray);                        end;                    end;                                        if correction(1) == 1 || correction(1) == 2                        minIntensity = 0;                    else                        minIntensity = referenceMinIntensity;                    end;                                        intensityStatistics = zeros(splitting, 2);                    for i = 1:splitting                        xSlabStart = round((i - 1) * xSize / splitting + 1);                        xSlabStop  = round(i * xSize / splitting);                        temporaryArray = gaussArray{currentCamera}(xSlabStart:xSlabStop, :, :);                        temporaryArray = temporaryArray(temporaryArray > minIntensity);                        intensityStatistics(i, 1) = sum(temporaryArray);                        intensityStatistics(i, 2) = size(temporaryArray, 1);                    end;                    meanIntensity = sum(intensityStatistics(:, 1)) / sum(intensityStatistics(:, 2));                    clear temporaryArray;                                        level = minIntensity + (meanIntensity - minIntensity) * maskFactor;                    threshold = round(xSize * ySize * zSize * fraction);                                        mask = gaussArray{currentCamera} > level;                    if fraction > 0                        mask = bwareaopen(mask, threshold);                    end;                                        sliceMask = zeros(xSize, ySize, 'uint16');                    for i = 1:splitting                        xSlabStart = round((i - 1) * xSize / splitting + 1);                        xSlabStop  = round(i * xSize / splitting);                        coordinateMask = repmat(reshape(1:zSize, [1 1 zSize]), [(xSlabStop - xSlabStart + 1) size(mask, 2) 1]);                        coordinateMask(mask(xSlabStart:xSlabStop, :, :) == 0) = NaN;                        sliceMask(xSlabStart:xSlabStop, :) = uint16(round(squeeze(nanmean(coordinateMask, 3))));                    end;                                        clear coordinateMask;                end;                                writeImage(sliceMask, mask2Name);                                sliceArray{find(cameras == c, 1)} = sliceMask;                                clear sliceMask;                                referenceMinIntensity = 0;            end;                    end;                if verbose == 2            disp(' ');        end;    end;        if processingMode == 2        referenceMinIntensityName = [outputString '.referenceMinIntensity.mat'];        save(referenceMinIntensityName, 'referenceMinIntensity');                minIntensity = referenceMinIntensity;    else        if correction(1) == 1 || correction(1) == 2            minIntensity = 0;        else            minIntensity = referenceMinIntensity;        end;    end;        if dataType == 0        for c = cameras            if verbose == 2                disp('--');                disp(['processing camera ' num2str(c)]);                disp('--');            end;                        if processingMode == 0                mask3Name = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.mask3D' outputExtension];                mask2Name = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.mask2D' outputExtension];            else                mask3Name = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.mask3D' outputExtension];                mask2Name = [outputHeader '_CM' num2str(c, '%.2d') '_CHN' num2str(channels(1), '%.2d') '.mask2D' outputExtension];            end;                        cameraSlot = find(cameras == c, 1);                        if exist(mask3Name, 'file') ~= 2 || enforceFlag(16)                intensityStatistics = zeros(splitting, 2);                for i = 1:splitting                    xSlabStart = round((i - 1) * xSize / splitting + 1);                    xSlabStop  = round(i * xSize / splitting);                    temporaryArray = gaussArray{cameraSlot}(xSlabStart:xSlabStop, :, :);                    temporaryArray = temporaryArray(temporaryArray > minIntensity);                    intensityStatistics(i, 1) = sum(temporaryArray);                    intensityStatistics(i, 2) = size(temporaryArray, 1);                end;                meanIntensity = sum(intensityStatistics(:, 1)) / sum(intensityStatistics(:, 2));                clear temporaryArray;                                level = minIntensity + (meanIntensity - minIntensity) * maskFactor;                threshold = round(xSize * ySize * zSize * fraction);                                if verbose == 2                    if fraction > 0                        disp(['thresholding gauss-convolved image stack using level ' num2str(round(level)) ' and size ' num2str(threshold)]);                    else                        disp(['thresholding gauss-convolved image stack using level ' num2str(round(level))]);                    end;                end;                mask = gaussArray{cameraSlot} > level;                if fraction > 0                    mask = bwareaopen(mask, threshold);                end;                                if ~reducedIO                    writeImage(uint16(mask), mask3Name);                end;            else                if verbose == 2                    disp(['reading thresholded image stack with ' num2str(zSize) ' planes']);                end;                mask = readImage(mask3Name);            end;                        if exist(mask2Name, 'file') ~= 2 || enforceFlag(17)                if verbose == 2                    disp('computing stack slice mask');                end;                                sliceMask = zeros(xSize, ySize, 'uint16');                for i = 1:splitting                    xSlabStart = round((i - 1) * xSize / splitting + 1);                    xSlabStop  = round(i * xSize / splitting);                    coordinateMask = repmat(reshape(1:zSize, [1 1 zSize]), [(xSlabStop - xSlabStart + 1) size(mask, 2) 1]);                    coordinateMask(mask(xSlabStart:xSlabStop, :, :) == 0) = NaN;                    sliceMask(xSlabStart:xSlabStop, :) = uint16(round(squeeze(nanmean(coordinateMask, 3))));                end;                                clear coordinateMask;                                writeImage(sliceMask, mask2Name);            else                if verbose == 2                    disp('reading stack slice mask');                end;                sliceMask = readImage(mask2Name);            end;                        sliceArray{cameraSlot} = sliceMask;                        clear mask;                        if verbose == 2                disp(' ');            end;        end;    end;        clear gaussArray;        if verbose == 2        disp('--');        disp(['processing slicing data for cameras ' num2str(cameras(1)) ' and ' num2str(cameras(2))]);        disp('--');    end;        if verbose == 2        disp('determining average slicing topology');    end;        if maskFusion == 0        % consider only regions that exist in both masks        overlap = (sliceArray{1} > 0) & (sliceArray{2} > 0);        averageMask = uint16((double(sliceArray{1}) .* double(overlap) + double(sliceArray{2}) .* double(overlap)) ./ 2);    else        % consider regions that exist in either of the two masks        overlap = (sliceArray{1} > 0) & (sliceArray{2} > 0);        averageMask = uint16((double(sliceArray{1}) .* double(overlap) + double(sliceArray{2}) .* double(overlap)) ./ 2);        averageMask = averageMask + ...            uint16(double(sliceArray{1}) .* double(sliceArray{1} > 0) .* double(averageMask == 0)) + ...            uint16(double(sliceArray{2}) .* double(sliceArray{2} > 0) .* double(averageMask == 0));    end;        localAnomalies = sum(averageMask(:) > (zSize - blending(2))) + sum(averageMask(averageMask(:) ~= 0) < blending(2));    if localAnomalies > 0        if verbose == 2            disp(['removing ' num2str(localAnomalies) ' mask anomalies']);        end;                averageMask(averageMask > (zSize - blending(2))) = 0;        averageMask(averageMask < blending(2)) = 0;    else        if verbose == 2            disp('no mask anomalies detected');        end;    end;        if fusionType == 1        if transitions(2) == 0            averageMask(averageMask > 0) = round(zSize / 2);        else            averageMask(averageMask > 0) = transitions(2);        end;    end;        averageMaskName = [outputString '.mask' outputExtension];    writeImage(averageMask, averageMaskName);        minMask = min(averageMask(averageMask > 0));    maxMask = max(averageMask(:));        lowerBound = double(minMask) - double(slabSizes(2));    if lowerBound < 1        lowerSlabSize = slabSizes(2) + lowerBound - 1;    else        lowerSlabSize = slabSizes(2);    end;        upperBound = double(maxMask) + double(slabSizes(2)) - double(zSize);    if upperBound > 0        upperSlabSize = slabSizes(2) - upperBound;    else        upperSlabSize = slabSizes(2);    end;        finalSlabSize = lowerSlabSize + upperSlabSize + 1;        dataSlice1 = zeros(xSize, ySize, finalSlabSize, 'uint16');    dataSlice2 = zeros(xSize, ySize, finalSlabSize, 'uint16');    for y = 1:ySize        for x = 1:xSize            if averageMask(x, y) > 0                currentIndexArray = (averageMask(x, y) - lowerSlabSize):(averageMask(x, y) + upperSlabSize);                dataSlice1(x, y, :) = primaryDataArray{1, 1}(x, y, currentIndexArray);                dataSlice2(x, y, :) = primaryDataArray{2, 1}(x, y, currentIndexArray);            end;        end;    end;        if processingMode == 0        dataSlice1Name = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.dataSlice' outputExtension];        dataSlice2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.dataSlice' outputExtension];    else        dataSlice1Name = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.dataSlice' outputExtension];        dataSlice2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.dataSlice' outputExtension];    end;        if processingMode == 0 && (correction(1) == 1 || correction(1) == 2)        intensityOffset = 0;    else        backgroundArray1 = dataSlice1(1:subSampling(1):end);        backgroundArray2 = dataSlice2(1:subSampling(1):end);        intensityOffset = prctile(cat(2, backgroundArray1(backgroundArray1 > 0), backgroundArray2(backgroundArray2 > 0)), percentile);        clear backgroundArray1 backgroundArray2;                dataSlice1 = dataSlice1 - intensityOffset;        dataSlice2 = dataSlice2 - intensityOffset;    end;        if medianFilter > 0                gaussFilterSizeArray  = [gaussFilter(1) max(1, gaussFilter(1) / scaling)];        gaussFilterSigmaArray = [gaussFilter(2) max(1, gaussFilter(2) / scaling)];        medianFilterArray = [medianFilter max(1, round(medianFilter / scaling))];                for p = 1:finalSlabSize            if gaussFilter(1) == 0                dataSlice1(:, :, p) = dataSlice1(:, :, p) - medfilt2(dataSlice1(:, :, p), medianFilterArray, 'symmetric');                dataSlice2(:, :, p) = dataSlice2(:, :, p) - medfilt2(dataSlice2(:, :, p), medianFilterArray, 'symmetric');            else                dataSlice1(:, :, p) = uint16(imgaussianAnisotropy(double(dataSlice1(:, :, p)), gaussFilterSigmaArray, gaussFilterSizeArray)) - medfilt2(dataSlice1(:, :, p), medianFilterArray, 'symmetric');                dataSlice2(:, :, p) = uint16(imgaussianAnisotropy(double(dataSlice2(:, :, p)), gaussFilterSigmaArray, gaussFilterSizeArray)) - medfilt2(dataSlice2(:, :, p), medianFilterArray, 'symmetric');            end;        end;    end;        if ~reducedIO || reducedIO == 2        writeImage(dataSlice1, dataSlice1Name);        writeImage(dataSlice2, dataSlice2Name);    end;        transformationName = [outputString '.transformation.mat'];        if exist(transformationName, 'file') ~= 2 || enforceFlag(18)        if verbose == 2            disp(['transforming x-offsets ' num2str(xOffsets(1)) ' to ' num2str(xOffsets(end)) ' in ' num2str(length(xOffsets)) ...                ' steps and y-offsets ' num2str(yOffsets(1)) ' to ' num2str(yOffsets(end)) ' in ' num2str(length(yOffsets)) ' steps']);        end;                intensityReference = sum(dataSlice1(:));                for x = 1:length(xOffsets)            translatedSlice = zeros(size(dataSlice2, 1), size(dataSlice2, 2), size(dataSlice2, 3));            if xOffsets(x) >= 0                translatedSlice((1 + xOffsets(x)):end, :, :) = dataSlice2(1:(end - xOffsets(x)), :, :);            else                translatedSlice(1:(end + xOffsets(x)), :, :) = dataSlice2((1 - xOffsets(x)):end, :, :);            end;            for y = 1:length(yOffsets)                correlationSlice = zeros(size(dataSlice2, 1), size(dataSlice2, 2), size(dataSlice2, 3));                if yOffsets(y) >= 0                    correlationSlice(:, (1 + yOffsets(y)):end, :) = translatedSlice(:, 1:(end - yOffsets(y)), :);                else                    correlationSlice(:, 1:(end + yOffsets(y)), :) = translatedSlice(:, (1 - yOffsets(y)):end, :);                end;                intensities(x, y) = sum(correlationSlice(:));                                intensityProduct = double(dataSlice1) .* correlationSlice;                scores(x, y, 3) = sum(intensityProduct(:)) / (intensityReference * intensities(x, y));            end;        end;                if reducedIO == 0 || reducedIO == 2            figure('Visible', 'off');            imagesc(scores(:, :, 3));            c = colorbar; set(c, 'FontSize', 14, 'LineWidth', 1.5);            ylabel(c, 'correlation score');            h = gca; set(h, 'FontSize', 14, 'LineWidth', 1.5);            xlabel(h, 'y-offset (pixels)'); ylabel(h, 'x-offset (pixels)');            set(h, 'XTick', [1 round(length(yOffsets) / 2) length(yOffsets)]);            set(h, 'XTickLabel', yOffsets([1 round(length(yOffsets) / 2) length(yOffsets)]));            set(h, 'YTick', [1 round(length(xOffsets) / 2) length(xOffsets)]);            set(h, 'YTickLabel', xOffsets([1 round(length(xOffsets) / 2) length(xOffsets)]));            currentFile = [outputString '.scores.png']; saveas(h, currentFile);            currentFrame = imread(currentFile); imwrite(currentFrame, currentFile, 'png');            close;        else            currentFile = [outputString '.scores.png'];            imwrite(uint16(scores(:, :, 3) * ((2 ^ 16 - 1) / max(max(scores(:, :, 3))))), currentFile);        end;                onlyScores = scores(:, :, 3);        bestScoreIndex = find(onlyScores == max(max(onlyScores)), 1);        onlyXOffsets = scores(:, :, 1);        onlyYOffsets = scores(:, :, 2);                bestXOffset = onlyXOffsets(bestScoreIndex);        bestYOffset = onlyYOffsets(bestScoreIndex);        if verbose == 2            disp(['results for coarse transformation: optimal x-offset = ' num2str(bestXOffset) ', optimal y-offset = ' num2str(bestYOffset)]);        end;                if verbose == 2            disp('determining optimal transformation');        end;                fun = @(x)transformCamera(x, double(dataSlice1), double(dataSlice2));        x0 = [bestXOffset bestYOffset 0]; % initial point: x0(1) = x-offset, x0(2) = y-offset, x0(3) = rotation around z in degrees        optionsOpt = optimset('Display', 'off', 'TolFun', 1e-12, 'TolX', 1e-3, 'GradObj', 'off', 'LargeScale', 'off');        stepSize = [1.0 1.0 0.1];                if optimizer == 1            [xSol, fval, exitflag] = fminunc(fun, x0, optionsOpt);    % uses approximation of Newton method        elseif optimizer == 2            [xSol, fval, exitflag] = fminsearch(fun, x0, optionsOpt); % uses Nelder-Mead simplex (direct search) method, slower        elseif optimizer == 3            [xSol, fval, exitflag] = fminuncFA(fun, x0,stepSize);     % uses gradient descent (by Fernando Amat)        end;                bestXOffset = xSol(1);        bestYOffset = xSol(2);        bestRotation = xSol(3);                transformation = [bestXOffset bestYOffset bestRotation];        save(transformationName, 'transformation');                if verbose == 2            disp(['results for final transformation: optimal x-offset = ' num2str(bestXOffset) ', optimal y-offset = ' num2str(bestYOffset) ', optimal rotation angle = ' num2str(bestRotation)]);        end;    else        if verbose == 2            disp('reading optimal transformation');        end;                load(transformationName);        bestXOffset = transformation(1);        bestYOffset = transformation(2);        bestRotation = transformation(3);                if verbose == 2            disp(['results for final transformation: optimal x-offset = ' num2str(bestXOffset) ', optimal y-offset = ' num2str(bestYOffset) ', optimal rotation angle = ' num2str(bestRotation)]);        end;    end;        if processingMode == 0        transformedSliceName = [outputHeader '_CM' num2str(cameras(2)) '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformedSlice' outputExtension];    else        transformedSliceName = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.transformedSlice' outputExtension];    end;        if (~reducedIO || reducedIO == 2) && exist(transformedSliceName, 'file') ~= 2                [XI YI] = meshgrid(1:size(dataSlice2, 1), 1:size(dataSlice2, 2));                RR = [ cosd(bestRotation) sind(bestRotation);...            -sind(bestRotation) cosd(bestRotation)];        cc = [(size(dataSlice2, 1) + 1) / 2.0 (size(dataSlice2, 2) + 1) / 2.0];        XI = XI' - cc(1);        YI = YI' - cc(2);        XZaux = (RR * [XI(:) YI(:)]')';        XI = reshape(XZaux(:, 1) + cc(1), size(XI));        YI = reshape(XZaux(:, 2) + cc(2), size(YI));                XI = XI - bestXOffset;        YI = YI - bestYOffset;                maskPos = find(XI < 1 | YI < 1 | XI > size(dataSlice2, 1) | YI > size(dataSlice2, 2));        maskTR = true(size(dataSlice2, 1), size(dataSlice2, 2));        maskTR(maskPos) = false;                correlationSlice = repmat(maskTR, [1 1 size(dataSlice2, 3)]) .* fInterpolate(double(dataSlice2), YI, XI, 'cubic');                writeImage(uint16(correlationSlice), transformedSliceName);    end;        if verbose == 2        disp(' ');    end;        if verbose == 2        disp('--');        disp(['transforming camera ' num2str(cameras(2)) ' data']);        disp('--');    end;        if processingMode == 0        transformedStackName = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformedStack' outputExtension];    else        transformedStackName = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.transformedStack' outputExtension];    end;        if exist(transformedStackName, 'file') ~= 2 || enforceFlag(19)        if verbose == 2            disp('transforming image stack');        end;                stackSlice = primaryDataArray{2, 1}(:, :, 1);                [XI YI] = meshgrid(1:size(stackSlice, 1), 1:size(stackSlice, 2));                RR = [ cosd(bestRotation) sind(bestRotation);...            -sind(bestRotation) cosd(bestRotation)];        cc = [(size(stackSlice, 1) + 1) / 2.0 (size(stackSlice, 2) + 1) / 2.0];        XI = XI' - cc(1);        YI = YI' - cc(2);        XZaux = (RR * [XI(:) YI(:)]')';        XI = reshape(XZaux(:, 1) + cc(1), size(XI));        YI = reshape(XZaux(:, 2) + cc(2), size(YI));                XI = XI - bestXOffset;        YI = YI - bestYOffset;                maskPos = find(XI < 1 | YI < 1 | XI > size(stackSlice, 1) | YI > size(stackSlice, 2));        maskTR = true(size(stackSlice, 1), size(stackSlice, 2));        maskTR(maskPos) = false;                transformedStack = zeros(xSize, ySize, zSize, 'uint16');        for i = 1:splitting            zSlabStart = round((i - 1) * zSize / splitting + 1);            zSlabStop  = round(i * zSize / splitting);            transformedStack(:, :, zSlabStart:zSlabStop) = ...                uint16(bsxfun(@times, maskTR, fInterpolate(double(primaryDataArray{2, 1}(:, :, zSlabStart:zSlabStop)), YI, XI, 'cubic')));        end;                if ~reducedIO            writeImage(transformedStack, transformedStackName);        end;    else        if verbose == 2            disp('reading transformed image stack');        end;                transformedStack = readImage(transformedStackName);    end;        primaryDataArray{2, 1} = transformedStack;    clear transformedStack;        if verbose == 2        disp(' ');    end;        time = toc;    if verbose == 1        disp(['***  camera alignment completed in ' num2str(floor(floor(time / 60) / 60), '%.2d') ':' num2str(mod(floor(time / 60), 60), '%.2d') ':' num2str(round(mod(time, 60)), '%.2d')]);    elseif verbose == 2        disp(['*** camera alignment completed in ' num2str(floor(floor(time / 60) / 60), '%.2d') ':' num2str(mod(floor(time / 60), 60), '%.2d') ':' num2str(round(mod(time, 60)), '%.2d')]);    end;        if verbose == 2        disp(' ');    end;        %% fuseCameras.m        tic;        if dataType == 1                if processingMode == 2            mask2Name = [inputFolder '/' inputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.xyMask' inputExtension];        else            mask2Name = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.xyMask' outputExtension];        end;        sliceArray{1} = readImage(mask2Name);                if processingMode == 2            mask2Name = [inputFolder '/' inputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.xyMask' inputExtension];        else            mask2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.xyMask' outputExtension];        end;        if processingMode == 2 && flipHFlag            sliceArray{2} = fliplr(readImage(mask2Name));        else            sliceArray{2} = readImage(mask2Name);        end;        if processingMode == 2 && flipVFlag            sliceArray{2} = flipud(sliceArray{2});        end;                transformationName = [outputString '.transformation.mat'];        load(transformationName, 'transformation');        bestXOffset = transformation(1);        bestYOffset = transformation(2);        bestRotation = transformation(3);                [XI YI] = meshgrid(1:size(sliceArray{2}, 1), 1:size(sliceArray{2}, 2));                RR = [ cosd(bestRotation) sind(bestRotation);...            -sind(bestRotation) cosd(bestRotation)];        cc = [(size(sliceArray{2}, 1) + 1) / 2.0 (size(sliceArray{2}, 2) + 1) / 2.0];        XI = XI' - cc(1);        YI = YI' - cc(2);        XZaux = (RR * [XI(:) YI(:)]')';        XI = reshape(XZaux(:, 1) + cc(1), size(XI));        YI = reshape(XZaux(:, 2) + cc(2), size(YI));                XI = XI - bestXOffset;        YI = YI - bestYOffset;                maskPos = find(XI < 1 | YI < 1 | XI > size(sliceArray{2}, 1) | YI > size(sliceArray{2}, 2));        maskTR = true(size(sliceArray{2}, 1), size(sliceArray{2}, 2));        maskTR(maskPos) = false;                sliceArray{2} = uint16(repmat(maskTR, [1 1 size(sliceArray{2}, 3)]) .* fInterpolate(double(sliceArray{2}), YI, XI, 'nearest'));                if processingMode == 2            transformedMask2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.xyMaskTransformed' outputExtension];        else            transformedMask2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.xyMaskTransformed' outputExtension];        end;        writeImage(sliceArray{2}, transformedMask2Name);            else                if processingMode == 0            mask2Name = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.mask2D' outputExtension];        else            mask2Name = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.mask2D' outputExtension];        end;        sliceArray{1} = readImage(mask2Name);        sliceArray{2} = [];                if verbose == 2            disp('--');            disp(['preparing data for camera ' num2str(cameras(2))]);            disp('--');        end;                if processingMode == 0            gaussName = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformedGauss' outputExtension];        else            gaussName = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.transformedGauss' outputExtension];        end;                if exist(gaussName, 'file') ~= 2 || enforceFlag(20)            if verbose == 2                disp(['gauss convolution with kernel size ' num2str(kernelSize) ' and sigma ' num2str(kernelSigma)]);            end;                        kernelSizeArray  = [kernelSize  kernelSize  max(1, kernelSize / scaling)];            kernelSigmaArray = [kernelSigma kernelSigma max(1, kernelSigma / scaling)];                        if splitting > 1                gaussStack = zeros(xSize, ySize, zSize, 'uint16');                                splittingMargin = 2 * kernelSize;                                for i = 1:splitting                    xSlabStart = max(1, round((i - 1) * xSize / splitting + 1 - splittingMargin));                    xSlabStop = min(xSize, round(i * xSize / splitting + splittingMargin));                    if preciseGauss                        convolvedSlab = uint16(imgaussianAnisotropy(double(primaryDataArray{2, 1}(xSlabStart:xSlabStop, :, :)), kernelSigmaArray, kernelSizeArray));                    else                        convolvedSlab = imgaussianAnisotropy(primaryDataArray{2, 1}(xSlabStart:xSlabStop, :, :), kernelSigmaArray, kernelSizeArray);                    end;                    if i == 1                        gaussStack(1:(xSlabStop - splittingMargin), :, :) = convolvedSlab(1:(end - splittingMargin), :, :);                    elseif i == splitting                        gaussStack((xSlabStart + splittingMargin):end, :, :) = convolvedSlab((1 + splittingMargin):end, :, :);                    else % i > 1 && i < splitting                        gaussStack((xSlabStart + splittingMargin):(xSlabStop - splittingMargin), :, :) = convolvedSlab((1 + splittingMargin):(end - splittingMargin), :, :);                    end;                    clear convolvedSlab;                end;            else                if preciseGauss                    gaussStack = uint16(imgaussianAnisotropy(double(primaryDataArray{2, 1}), kernelSigmaArray, kernelSizeArray));                else                    gaussStack = imgaussianAnisotropy(primaryDataArray{2, 1}, kernelSigmaArray, kernelSizeArray);                end;            end;                        if ~reducedIO                writeImage(gaussStack, gaussName);            end;        else            if verbose == 2                disp(['reading gauss-convolved image stack with ' num2str(zSize) ' planes']);            end;            gaussStack = readImage(gaussName);        end;                if verbose == 2            disp(' ');        end;                if processingMode == 0            mask3Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformedMask3D' outputExtension];            mask2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.transformedMask2D' outputExtension];        else            mask3Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.transformedMask3D' outputExtension];            mask2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.transformedMask2D' outputExtension];        end;                if exist(mask3Name, 'file') ~= 2 || enforceFlag(21)            if processingMode == 0 && (correction(1) == 1 || correction(1) == 2)                intensityThreshold = 0;            else                intensityThreshold =  referenceMinIntensity;            end;            intensityStatistics = zeros(splitting, 2);            for i = 1:splitting                xSlabStart = round((i - 1) * xSize / splitting + 1);                xSlabStop  = round(i * xSize / splitting);                temporaryArray = gaussStack(xSlabStart:xSlabStop, :, :);                temporaryArray = temporaryArray(temporaryArray > intensityThreshold);                intensityStatistics(i, 1) = sum(temporaryArray);                intensityStatistics(i, 2) = size(temporaryArray, 1);            end;            meanIntensity = sum(intensityStatistics(:, 1)) / sum(intensityStatistics(:, 2));            clear temporaryArray;                        level = minIntensity + (meanIntensity - minIntensity) * maskFactor; % minIntensity propagates from alignCameras.m            threshold = round(xSize * ySize * zSize * fraction);                        if verbose == 2                if fraction > 0                    disp(['thresholding gauss-convolved image stack using level ' num2str(round(level)) ' and size ' num2str(threshold)]);                else                    disp(['thresholding gauss-convolved image stack using level ' num2str(round(level))]);                end;            end;            mask = gaussStack > level;                        clear gaussStack;                        if fraction > 0                mask = bwareaopen(mask, threshold);            end;                        if ~reducedIO                writeImage(uint16(mask), mask3Name);            end;        else            if verbose == 2                disp(['reading thresholded image stack with ' num2str(zSize) ' planes']);            end;                        clear gaussStack;                        mask = readImage(mask3Name);        end;                if exist(mask2Name, 'file') ~= 2 || enforceFlag(22)            if verbose == 2                disp('computing stack slice mask');            end;                        sliceMask = zeros(xSize, ySize, 'uint16');            for i = 1:splitting                xSlabStart = round((i - 1) * xSize / splitting + 1);                xSlabStop  = round(i * xSize / splitting);                coordinateMask = repmat(reshape(1:zSize, [1 1 zSize]), [(xSlabStop - xSlabStart + 1) size(mask, 2) 1]);                coordinateMask(mask(xSlabStart:xSlabStop, :, :) == 0) = NaN;                sliceMask(xSlabStart:xSlabStop, :) = uint16(round(squeeze(nanmean(coordinateMask, 3))));            end;                        clear coordinateMask;                        writeImage(sliceMask, mask2Name);        else            if verbose == 2                disp('reading stack slice mask');            end;            sliceMask = readImage(mask2Name);        end;                clear mask;                sliceArray{2} = sliceMask;                if verbose == 2            disp(' ');        end;            end;        if verbose == 2        disp('--');        disp(['processing slicing data for cameras ' num2str(cameras(1)) ' and ' num2str(cameras(2))]);        disp('--');    end;        if verbose == 2        disp('determining average slicing topology');    end;        if maskFusion == 0        % consider only regions that exist in both masks        overlap = (sliceArray{1} > 0) & (sliceArray{2} > 0);        averageMask = uint16((double(sliceArray{1}) .* double(overlap) + double(sliceArray{2}) .* double(overlap)) ./ 2);    else        % consider regions that exist in either of the two masks        overlap = (sliceArray{1} > 0) & (sliceArray{2} > 0);        averageMask = uint16((double(sliceArray{1}) .* double(overlap) + double(sliceArray{2}) .* double(overlap)) ./ 2);        averageMask = averageMask + ...            uint16(double(sliceArray{1}) .* double(sliceArray{1} > 0) .* double(averageMask == 0)) + ...            uint16(double(sliceArray{2}) .* double(sliceArray{2} > 0) .* double(averageMask == 0));    end;        localAnomalies = sum(averageMask(:) > (zSize - blending(2))) + sum(averageMask(averageMask(:) ~= 0) < blending(2));    if localAnomalies > 0        if verbose == 2            disp(['removing ' num2str(localAnomalies) ' mask anomalies']);        end;                averageMask(averageMask > (zSize - blending(2))) = 0;        averageMask(averageMask < blending(2)) = 0;    else        if verbose == 2            disp('no mask anomalies detected');        end;    end;        if fusionType == 1        if transitions(2) == 0            averageMask(averageMask > 0) = round(zSize / 2);        else            averageMask(averageMask > 0) = transitions(2);        end;    end;        if padding(1) == 1        averageMask(averageMask == 0) = round(zSize / 2);    elseif padding(1) == 2        binaryMask = averageMask > 0;        dilatedMask = imdilate(binaryMask, strel('disk', padding(2)));        averageMask(~dilatedMask) = round(zSize / 2);                [A, B] = meshgrid(1:ySize, 1:xSize);        foregroundSlots = find(averageMask > 0);        transitionSlots = find(averageMask == 0);        f = scatteredInterpolant(A(foregroundSlots), B(foregroundSlots), double(averageMask(foregroundSlots)), 'natural');        transitionValues = f(A(transitionSlots), B(transitionSlots));        averageMask(transitionSlots) = transitionValues;        averageMask(averageMask < blending(2)) = blending(2);        averageMask(averageMask > (zSize - blending(2))) = (zSize - blending(2));    end;        averageMaskName = [outputString '.fusionMask' outputExtension];    writeImage(averageMask, averageMaskName);        if correction(2) == 1 || correction(2) == 2        if processingMode == 0 && (correction(1) == 1 || correction(1) == 2)            background = 0;        else            if dataType == 1 && processingMode == 2                minIntensityName = [inputFolder '/' inputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.minIntensity.mat'];                load(minIntensityName, 'minIntensity');                backgroundIntensity1 = minIntensity(end);                                minIntensityName = [inputFolder '/' inputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.minIntensity.mat'];                load(minIntensityName, 'minIntensity');                backgroundIntensity2 = minIntensity(end);            elseif dataType == 1 && processingMode == 0                background = 0;            else % dataType == 0                backgroundArray1 = primaryDataArray{1, 1}(1:subSampling(2):end);                backgroundArray2 = primaryDataArray{2, 1}(1:subSampling(2):end);                background = prctile(cat(2, backgroundArray1(backgroundArray1 > 0), backgroundArray2(backgroundArray2 > 0)), percentile);                clear backgroundArray1 backgroundArray2;            end;        end;                if correction(2) == 1            if verbose == 2                disp('analyzing intensity difference');            end;                        minMask = min(averageMask(averageMask > 0));            maxMask = max(averageMask(:));                        lowerBound = double(minMask) - double(intSizes(2));            if lowerBound < 1                lowerSlabSize = intSizes(2) + lowerBound - 1;            else                lowerSlabSize = intSizes(2);            end;                        upperBound = double(maxMask) + double(intSizes(2)) - double(zSize);            if upperBound > 0                upperSlabSize = intSizes(2) - upperBound;            else                upperSlabSize = intSizes(2);            end;                        finalSlabSize = lowerSlabSize + upperSlabSize + 1;                        dataSlice1 = zeros(xSize, zSize, finalSlabSize, 'uint16');            dataSlice2 = zeros(xSize, zSize, finalSlabSize, 'uint16');            for y = 1:ySize                for x = 1:xSize                    if averageMask(x, y) > 0                        currentIndexArray = (averageMask(x, y) - lowerSlabSize):(averageMask(x, y) + upperSlabSize);                        dataSlice1(x, y, :) = primaryDataArray{1, 1}(x, y, currentIndexArray);                        dataSlice2(x, y, :) = primaryDataArray{2, 1}(x, y, currentIndexArray);                    end;                end;            end;                        if dataType == 1 && processingMode == 2                dataSlice1 = dataSlice1 - backgroundIntensity1;                dataSlice2 = dataSlice2 - backgroundIntensity2;            elseif dataType == 0                dataSlice1 = dataSlice1 - background;                dataSlice2 = dataSlice2 - background;            end;                        if processingMode == 0                dataSlice1Name = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.fusionDataSlice' outputExtension];                dataSlice2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.fusionDataSlice' outputExtension];            else                dataSlice1Name = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.fusionDataSlice' outputExtension];                dataSlice2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.fusionDataSlice' outputExtension];            end;                        if ~reducedIO || reducedIO == 2                writeImage(dataSlice1, dataSlice1Name);                writeImage(dataSlice2, dataSlice2Name);            end;                        intensityList1 = double(dataSlice1(:));            intensitySum1 = sum(intensityList1(intensityList1 > 0));            intensityList2 = double(dataSlice2(:));            intensitySum2 = sum(intensityList2(intensityList2 > 0));                        if intensitySum1 > intensitySum2                correctionFactor = intensitySum1 / intensitySum2;                correctionFlag = 2;            else                correctionFactor = intensitySum2 / intensitySum1;                correctionFlag = 1;            end;                        if dataType == 1 && processingMode == 2                intensityCorrection = [double(backgroundIntensity1) double(backgroundIntensity2) double(intensitySum1) double(intensitySum2) double(correctionFactor) double(correctionFlag)];            else                intensityCorrection = [double(background) double(intensitySum1) double(intensitySum2) double(correctionFactor) double(correctionFlag)];            end;            intensityCorrectionName = [outputString '.intensityCorrection.mat'];            save(intensityCorrectionName, 'intensityCorrection');        else            if correction(4) > 1                correctionFactor = correction(4);                correctionFlag = 2;            else                correctionFactor = 1 / correction(4);                correctionFlag = 1;            end;        end;                if processingMode == 0            correctedStack1Name = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.correctedStack' outputExtension];            correctedStack2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '_CHN' num2str(channels(2), '%.2d') '.correctedStack' outputExtension];        else            correctedStack1Name = [outputHeader '_CM' num2str(cameras(1), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.correctedStack' outputExtension];            correctedStack2Name = [outputHeader '_CM' num2str(cameras(2), '%.2d') '_CHN' num2str(channels(1), '%.2d') '.correctedStack' outputExtension];        end;                if exist(correctedStack1Name, 'file') ~= 2 || exist(correctedStack2Name, 'file') ~= 2 || enforceFlag(23)            if verbose == 2                disp('correcting image stacks');            end;                        if dataType == 1 && processingMode == 2                primaryDataArray{1, 1} = primaryDataArray{1, 1} - backgroundIntensity1;                primaryDataArray{2, 1} = primaryDataArray{2, 1} - backgroundIntensity2;            elseif dataType == 0                primaryDataArray{1, 1} = primaryDataArray{1, 1} - background;                primaryDataArray{2, 1} = primaryDataArray{2, 1} - background;            end;            primaryDataArray{1, 1}(primaryDataArray{1, 1} < 0) = 0;            primaryDataArray{2, 1}(primaryDataArray{2, 1} < 0) = 0;                        if correctionFlag == 1                primaryDataArray{1, 1} = primaryDataArray{1, 1} .* correctionFactor;            else                primaryDataArray{2, 1} = primaryDataArray{2, 1} .* correctionFactor;            end;                        if ~reducedIO                writeImage(primaryDataArray{1, 1}, correctedStack1Name);                writeImage(primaryDataArray{2, 1}, correctedStack2Name);            end;        else            if verbose == 2                disp('reading intensity-corrected stacks');            end;                        primaryDataArray{1, 1} = readImage(correctedStack1Name);            primaryDataArray{2, 1} = readImage(correctedStack2Name);        end;    else        if verbose == 2            disp('skipping intensity correction');        end;    end;        if fusionType == 0 || fusionType == 1        stitchedStackName = [outputString '.stitchedStack' outputExtension];                if exist(stitchedStackName, 'file') ~= 2 || enforceFlag(24)            if verbose == 2                disp('stitching corrected stacks');            end;                        channelMask = bsxfun(@le, reshape(uint16(1:zSize), [1, 1, zSize]), averageMask);            if frontFlag == 1                fusedStack = bsxfun(@times, uint16(averageMask > 0), primaryDataArray{2, 1});                fusedStack(channelMask) = primaryDataArray{1, 1}(channelMask);            else                fusedStack = bsxfun(@times, uint16(averageMask > 0), primaryDataArray{1, 1});                fusedStack(channelMask) = primaryDataArray{2, 1}(channelMask);            end;            clear channelMask;                        if ~reducedIO                writeImage(fusedStack, stitchedStackName);            end;        else            if verbose == 2                disp('reading stitched stack');            end;                        fusedStack = readImage(stitchedStackName);        end;    end;        fusedStackName = [outputString '.fusedStack' outputExtension];        if exist(fusedStackName, 'file') ~= 2 || enforceFlag(25)        if fusionType == 0 || fusionType == 1            if verbose == 2                disp('blending corrected stacks');            end;                        weighting1Front = reshape((1:((0.5 - 1) / (blending(2) - 1)):0.5), [1 1 blending(2)]); % dominant fraction            weighting2Front = reshape((0:((0.5 - 0) / (blending(2) - 1)):0.5), [1 1 blending(2)]); % fading fraction                        weighting1Back = reshape((0.5:((1 - 0.5) / (blending(2) - 1)):1), [1 1 blending(2)]); % dominant fraction            weighting2Back = reshape((0.5:((0 - 0.5) / (blending(2) - 1)):0), [1 1 blending(2)]); % fading fraction                        if frontFlag == 1                for y = 1:ySize                    for x = 1:xSize                        if averageMask(x, y) > 0                            array1Front = double(primaryDataArray{1, 1}(x, y, (averageMask(x, y) - blending(2) + 1):averageMask(x, y)));                            array2Front = double(primaryDataArray{2, 1}(x, y, (averageMask(x, y) - blending(2) + 1):averageMask(x, y)));                            array1Back = double(primaryDataArray{1, 1}(x, y, (averageMask(x, y) + 1):(averageMask(x, y) + blending(2))));                            array2Back = double(primaryDataArray{2, 1}(x, y, (averageMask(x, y) + 1):(averageMask(x, y) + blending(2))));                            fusedStack(x, y, (averageMask(x, y) - blending(2) + 1):averageMask(x, y)) = uint16(array1Front .* weighting1Front + array2Front .* weighting2Front);                            fusedStack(x, y, (averageMask(x, y) + 1):(averageMask(x, y) + blending(2))) = uint16(array1Back .* weighting2Back + array2Back .* weighting1Back);                        end;                    end;                end;            else                for y = 1:ySize                    for x = 1:xSize                        if averageMask(x, y) > 0                            array1Front = double(primaryDataArray{1, 1}(x, y, (averageMask(x, y) - blending(2) + 1):averageMask(x, y)));                            array2Front = double(primaryDataArray{2, 1}(x, y, (averageMask(x, y) - blending(2) + 1):averageMask(x, y)));                            array1Back = double(primaryDataArray{1, 1}(x, y, (averageMask(x, y) + 1):(averageMask(x, y) + blending(2))));                            array2Back = double(primaryDataArray{2, 1}(x, y, (averageMask(x, y) + 1):(averageMask(x, y) + blending(2))));                            fusedStack(x, y, (averageMask(x, y) - blending(2) + 1):averageMask(x, y)) = uint16(array1Front .* weighting2Front + array2Front .* weighting1Front);                            fusedStack(x, y, (averageMask(x, y) + 1):(averageMask(x, y) + blending(2))) = uint16(array1Back .* weighting1Back + array2Back .* weighting2Back);                        end;                    end;                end;            end;        elseif fusionType == 2            if verbose == 2                disp('performing wavelet fusion of corrected stacks');            end;                        fusedStack = zeros(xSize, ySize, zSize, 'uint16');            for z = 1:zSize                fusedStack(:, :, z) = uint16(wfusimg(primaryDataArray{1, 1}(:, :, z), primaryDataArray{2, 1}(:, :, z), 'db4', 5, 'mean', 'max'));            end;        elseif fusionType == 3            if verbose == 2                disp('performing averaging of corrected stacks');            end;                        fusedStack = zeros(xSize, ySize, zSize, 'uint16');            for z = 1:zSize                fusedStack(:, :, z) = (primaryDataArray{1, 1}(:, :, z) + primaryDataArray{2, 1}(:, :, z)) ./ 2;            end;        end;                writeImage(fusedStack, fusedStackName);                fusedStackProjXYName = [outputString '.fusedStack_xyProjection' outputExtension];        fusedStackProjXZName = [outputString '.fusedStack_xzProjection' outputExtension];        fusedStackProjYZName = [outputString '.fusedStack_yzProjection' outputExtension];                writeImage(max(fusedStack, [], 3), fusedStackProjXYName);        writeImage(squeeze(max(fusedStack, [], 2)), fusedStackProjXZName);        writeImage(squeeze(max(fusedStack, [], 1)), fusedStackProjYZName);    end;        clear fusedStack;        if verbose == 2        disp(' ');    end;        time = toc;    if verbose == 1        disp(['***     camera fusion completed in ' num2str(floor(floor(time / 60) / 60), '%.2d') ':' num2str(mod(floor(time / 60), 60), '%.2d') ':' num2str(round(mod(time, 60)), '%.2d')]);        disp(' ');    elseif verbose == 2        disp(['*** camera fusion completed in ' num2str(floor(floor(time / 60) / 60), '%.2d') ':' num2str(mod(floor(time / 60), 60), '%.2d') ':' num2str(round(mod(time, 60)), '%.2d')]);        disp(' ');    end;end;jobCompleted = 1;save([outputString '_jobCompleted.txt'], '-ascii', 'jobCompleted');end%% Auxiliary function for anisotropic Gaussian filteringfunction I = imgaussianAnisotropy(I, sigma, siz)% ---------------------------------------------------------------------------------------------------% | Anisotropic Gaussian filtering                                                                  |% | Original function (imgaussian) written by D. Kroon, University of Twente, September 2009        |% | Code modification to allow different sigmas by Fernando Amat, HHMI/Janelia Farm, September 2010 |% ---------------------------------------------------------------------------------------------------% Note: If X is of type double, the MEX file is faster. For images of type single or int, this m-file is faster.if(~exist('siz', 'var'))    siz = sigma * 6;end;ndimsI = sum(size(I) > 1);if(length(sigma) ~= ndimsI)    error 'You must specify one sigma for each dimension of the image'end;% Filter each dimension with the 1D Gaussian kernelsif(ndimsI == 1)    % Make 1D Gaussian kernel    kk = 1;    x = -ceil(siz(kk) / 2):ceil(siz(kk) / 2);    H = exp(-(x .^ 2 / (2 * sigma(kk) ^ 2)));    H = H / sum(H(:));    I = imfilter(I, H, 'same', 'replicate');elseif(ndimsI == 2)    % Make 1D Gaussian kernel    kk = 1;    x = -ceil(siz(kk) / 2):ceil(siz(kk) / 2);    H = exp(-(x .^ 2 / (2 * sigma(kk) ^ 2)));    H = H / sum(H(:));    Hx = reshape(H, [length(H) 1]);        kk = 2;    x = -ceil(siz(kk) / 2):ceil(siz(kk) / 2);    H = exp(-(x .^ 2 / (2 * sigma(kk) ^ 2)));    H = H / sum(H(:));    Hy = reshape(H, [1 length(H)]);        I = imfilter(imfilter(I, Hx, 'same', 'replicate'), Hy, 'same', 'replicate');elseif(ndimsI == 3)    if(size(I, 3) < 4) % Detect if 3D or color image        % Make 1D Gaussian kernel        kk = 1;        x = -ceil(siz(kk) / 2):ceil(siz(kk) / 2);        H = exp(-(x .^ 2 / (2 * sigma(kk) ^ 2)));        H = H / sum(H(:));        Hx = reshape(H, [length(H) 1]);                kk = 2;        x = -ceil(siz(kk) / 2):ceil(siz(kk) / 2);        H = exp(-(x .^ 2 / (2 * sigma(kk) ^ 2)));        H = H / sum(H(:));        Hy = reshape(H, [1 length(H)]);        for k = 1:size(I, 3)            I(:, :, k) = imfilter(imfilter(I(:, :, k), Hx, 'same', 'replicate'), Hy, 'same', 'replicate');        end;    else        % Make 1D Gaussian kernel        kk = 1;        x = -ceil(siz(kk) / 2):ceil(siz(kk) / 2);        H = exp(-(x .^ 2 / (2 * sigma(kk) ^ 2)));        H = H / sum(H(:));        Hx = reshape(H, [length(H) 1 1]);                kk = 2;        x = -ceil(siz(kk) / 2):ceil(siz(kk) / 2);        H = exp(-(x .^ 2 / (2 * sigma(kk) ^ 2)));        H = H / sum(H(:));        Hy = reshape(H, [1 length(H) 1]);                kk = 3;        x = -ceil(siz(kk) / 2):ceil(siz(kk) / 2);        H = exp(-(x .^ 2 / (2 * sigma(kk) ^ 2)));        H = H / sum(H(:));        Hz = reshape(H, [1 1 length(H)]);                I = imfilter(imfilter(imfilter(I, Hx, 'same', 'replicate'), Hy, 'same', 'replicate'), Hz, 'same', 'replicate');    end;else    error('imgaussian:input', 'unsupported input dimension');end;end%% Auxiliary function for gradient descentfunction [xSol, fval, exitflag] = fminuncFA(fun, x0, stepSize)% --------------------------------------------------------------------------------------% | Simple gradient descent to find optimal image registration with adaptive step size |% | Code by Fernando Amat, HHMI/Janelia Farm, May 16th 2011                            |% --------------------------------------------------------------------------------------tolX       = 1e-3;tolFun     = 1e-6;  % function is normalized cross-correlation, values are between 1 and -1maxNumEval = 400;   % maximum number of function evaluationsbeta       = 0.5;alpha      = 1.0;   % adds memory to beta and avoids unnecessar line search operationsdebug      = false; % set to true if you want to follow improvement for each iterationN = length(x0);g = zeros(size(x0));numEval = 0;f0 = fun(x0);numEval = numEval + 1;fh = f0;xh = x0;if debug    disp(['fVal = ' num2str(f0) '; x = ' num2str(x0) '; cumNumEval = ' num2str(numEval)]);end;while 1    % calculate gradient    for kk = 1:N        h = zeros(size(x0));        h(kk) = stepSize(kk);        fp = fun(x0 + h);        % help convergence in flat regions        if(fp < fh)            fh = fp;            xh = x0 + h;        end;        fm = fun(x0 - h);        if fm < fh            fh = fm;            xh = x0 - h;        end;        g(kk) = (fp - fm) / (2.0 * stepSize(kk));        numEval = numEval + 2;    end;        % line search    mu = alpha * 5 * min(abs(stepSize ./ g));    f1 = fun(x0 - mu * g);    numEval = numEval + 1;    auxAlpha = 1.0;    while (f1 > f0) && (norm(mu * g) > tolX)        mu = mu * beta;        f1 = fun(x0 - mu * g);        numEval = numEval + 1;        auxAlpha = auxAlpha * beta;    end;        % update alpha: moving average to reduce testing of beta    alpha = 0.3 * alpha + (1.0 - 0.3) * alpha * auxAlpha;        % check for convergence     if (norm(mu * g) < tolX) && ((fh + tolFun) >= min(f1, f0))        exitflag = 2;        if f1 < f0            xSol = x0 - mu * g;            fval = f1;        else            xSol = x0;            fval = f0;        end;        return;    end;        if ((abs(f1 - f0) / abs(f0)) < tolFun) && ((fh + tolFun) >= min(f1, f0))        exitflag = 1;        if f1 < f0            xSol = x0 - mu * g;            fval = f1;        else            xSol = x0;            fval = f0;        end;        return;    end;       % update optimal position    if f1 <= fh        x0 = x0 - mu * g;        f0 = f1;    else        x0 = xh;        f0 = fh;    end;    fh = f0;    xh = x0;        if debug       disp(['fVal = ' num2str(f1, '%3.15f') '; x = ' num2str(x0, '%3.10f') '; norm(mu * g) = ' num2str(norm(mu * g), '%3.10f') '; cumNumEval = ' num2str(numEval)]);    end;        if(numEval > maxNumEval)        exitflag = 3;        xSol = x0;        fval = f0;        return;    end;end;end%% Auxiliary function for light sheet alignmentfunction fVal = transformChannel(x, dataSlice1, dataSlice2, scaling)% -------------------------------------------------------------% | Auxiliary function for light sheet alignment              |% | Code by Fernando Amat, HHMI/Janelia Farm, April 14th 2011 |% -------------------------------------------------------------% x(1) = zOffset;% x(2) = rotation in degrees;zOffsets  = x(1);rotations = x(2);% translate and rotate slice all at once in a single interpolation% FIRST translation and SECOND rotation% this can be used as sample code to efficiently implement translation and rotation[XI ZI] = meshgrid(1:size(dataSlice2, 1), 1:size(dataSlice2, 2));RR = [cosd(rotations) -sind(rotations);...      sind(rotations)  cosd(rotations)];cc = [(size(dataSlice2, 1) + 1) / 2.0 (size(dataSlice2, 2) + 1) / 2.0];XI = XI' - cc(1);ZI = ZI' - cc(2);XZaux = [XI(:) ZI(:) .* scaling] * RR;XI = reshape(XZaux(:, 1) + cc(1), size(XI));ZI = reshape(XZaux(:, 2) ./ scaling + cc(2), size(ZI));ZI = ZI - zOffsets;% transform dataSlicetranslatedRotatedSlice = fInterpolate(dataSlice2, ZI, XI, 'cubic');% calculate normalized correlation for optimizationmaskPos = find(XI >= 1 | ZI >= 1 | XI <= size(dataSlice2, 1) | ZI <= size(dataSlice2, 2));fValAux = corrcoef(translatedRotatedSlice(maskPos), dataSlice1(maskPos));fVal = -fValAux(2);end%% Auxiliary function for camera alignmentfunction fVal = transformCamera(x, dataSlice1, dataSlice2)% -------------------------------------------------------------% | Auxiliary function for camera alignment                   |% | Code by Fernando Amat, HHMI/Janelia Farm, April 14th 2011 |% -------------------------------------------------------------% x(1) = xOffset;% x(2) = yOffset;% x(3) = rotation in Z (in degrees);xOffsets  = x(1);yOffsets  = x(2);rotations = x(3);% translate and rotate slice all at once in a single interpolation% FIRST translation and SECOND rotation% this can be used as sample code to efficiently implement translation and rotation[XI YI] = meshgrid(1:size(dataSlice2, 1), 1:size(dataSlice2, 2));RR = [cosd(rotations) -sind(rotations);...      sind(rotations)  cosd(rotations)];cc = [(size(dataSlice2, 1) + 1) / 2.0 (size(dataSlice2, 2) + 1) / 2.0];XI = XI' - cc(1);YI = YI' - cc(2);XZaux = [XI(:) YI(:)] * RR;XI = reshape(XZaux(:, 1) + cc(1), size(XI));YI = reshape(XZaux(:, 2) + cc(2), size(YI));XI = XI - xOffsets; YI = YI - yOffsets;% fInterpolate applies the same rotation to all the XY planes, we avoid for looptranslatedRotatedSlice = fInterpolate(double(dataSlice2), YI, XI, 'cubic');% calculate normalized correlation for optimizationmaskPos = find(XI >= 0 | YI >= 0 | XI <= size(dataSlice2, 1) | YI <= size(dataSlice2, 2));fValAux = corrcoef(translatedRotatedSlice(maskPos), dataSlice1(maskPos));fVal = -fValAux(2);end